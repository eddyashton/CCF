/* This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
 * KreMLin invocation: /mnt/e/everest/verify/kremlin/krml -skip-compilation -minimal -tmpdir dist/ccf/ .output/prims.krml .output/FStar_Pervasives_Native.krml .output/FStar_Pervasives.krml .output/FStar_Mul.krml .output/FStar_Squash.krml .output/FStar_Classical.krml .output/FStar_StrongExcludedMiddle.krml .output/FStar_FunctionalExtensionality.krml .output/FStar_List_Tot_Base.krml .output/FStar_List_Tot_Properties.krml .output/FStar_List_Tot.krml .output/FStar_Seq_Base.krml .output/FStar_Seq_Properties.krml .output/FStar_Seq.krml .output/FStar_Math_Lib.krml .output/FStar_Math_Lemmas.krml .output/FStar_BitVector.krml .output/FStar_UInt.krml .output/FStar_UInt32.krml .output/FStar_Int.krml .output/FStar_Int16.krml .output/Opaque_s.krml .output/Collections_Seqs_s.krml .output/FStar_UInt8.krml .output/Words_s.krml .output/Words_Four_s.krml .output/Words_Two_s.krml .output/Words_Seq_s.krml .output/Types_s.krml .output/TypesNative_s.krml .output/Arch_TypesNative.krml .output/Prop_s.krml .output/Util_Meta.krml .output/FStar_Set.krml .output/FStar_Map.krml .output/X64_Machine_s.krml .output/X64_CPU_Features_s.krml .output/Map16.krml .output/X64_Vale_Xmms.krml .output/X64_Vale_Regs.krml .output/FStar_Float.krml .output/FStar_UInt64.krml .output/FStar_Exn.krml .output/FStar_Preorder.krml .output/FStar_Monotonic_Witnessed.krml .output/FStar_Ghost.krml .output/FStar_ErasedLogic.krml .output/FStar_PropositionalExtensionality.krml .output/FStar_PredicateExtensionality.krml .output/FStar_TSet.krml .output/FStar_Monotonic_Heap.krml .output/FStar_Heap.krml .output/FStar_ST.krml .output/FStar_All.krml .output/FStar_IO.krml .output/Words_Two.krml .output/Collections_Seqs.krml .output/Words_Seq.krml .output/Arch_Types.krml .output/AES_s.krml .output/Math_Poly2_Defs_s.krml .output/Math_Poly2_s.krml .output/Math_Poly2_Bits_s.krml .output/FStar_Monotonic_HyperHeap.krml .output/FStar_Monotonic_HyperStack.krml .output/FStar_HyperStack.krml .output/FStar_HyperStack_ST.krml .output/FStar_HyperStack_All.krml .output/FStar_Kremlin_Endianness.krml .output/FStar_Int64.krml .output/FStar_Int63.krml .output/FStar_Int32.krml .output/FStar_Int8.krml .output/FStar_UInt63.krml .output/FStar_UInt16.krml .output/FStar_Int_Cast.krml .output/FStar_UInt128.krml .output/Spec_Hash_Definitions.krml .output/Spec_Hash_Lemmas0.krml .output/Spec_Hash_PadFinish.krml .output/Spec_Loops.krml .output/FStar_List.krml .output/Spec_SHA2_Constants.krml .output/Spec_SHA2.krml .output/X64_CryptoInstructions_s.krml .output/X64_Bytes_Semantics_s.krml .output/FStar_Char.krml .output/FStar_BaseTypes.krml .output/X64_Taint_Semantics_s.krml .output/X64_Bytes_Semantics.krml .output/FStar_Universe.krml .output/FStar_GSet.krml .output/FStar_ModifiesGen.krml .output/FStar_Range.krml .output/FStar_Reflection_Types.krml .output/FStar_Tactics_Types.krml .output/FStar_Tactics_Result.krml .output/FStar_Tactics_Effect.krml .output/FStar_Tactics_Util.krml .output/FStar_Reflection_Data.krml .output/FStar_Reflection_Const.krml .output/FStar_String.krml .output/FStar_Order.krml .output/FStar_Reflection_Basic.krml .output/FStar_Reflection_Derived.krml .output/FStar_Tactics_Builtins.krml .output/FStar_Reflection_Formula.krml .output/FStar_Reflection_Derived_Lemmas.krml .output/FStar_Reflection.krml .output/FStar_Tactics_Derived.krml .output/FStar_Tactics_Logic.krml .output/FStar_Tactics.krml .output/FStar_BigOps.krml .output/LowStar_Monotonic_Buffer.krml .output/LowStar_BufferView.krml .output/Views.krml .output/LowStar_Buffer.krml .output/LowStar_Modifies.krml .output/LowStar_ModifiesPat.krml .output/Interop.krml .output/X64_Memory.krml .output/BufferViewHelpers.krml .output/X64_BufferViewStore.krml .output/X64_Memory_Sems.krml .output/X64_Vale_State.krml .output/X64_Vale_StateLemmas.krml .output/X64_Vale_Lemmas.krml .output/X64_Print_s.krml .output/X64_Vale_Decls.krml .output/X64_Vale_QuickCode.krml .output/X64_Vale_QuickCodes.krml .output/X64_Taint_Semantics.krml .output/X64_Vale_InsLemmas.krml .output/X64_Vale_InsBasic.krml .output/X64_Cpuid.krml .output/X64_Cpuidstdcall.krml .output/Vale_check_aesni_stdcall.krml .output/Spec_SHA1.krml .output/Spec_MD5.krml .output/Spec_Hash.krml .output/Spec_Hash_Incremental.krml .output/Spec_Hash_Lemmas.krml .output/LowStar_BufferOps.krml .output/C_Loops.krml .output/C_Endianness.krml .output/Hacl_Hash_Lemmas.krml .output/Hacl_Hash_Definitions.krml .output/FStar_Int_Cast_Full.krml .output/Hacl_Hash_PadFinish.krml .output/Hacl_Hash_MD.krml .output/X64_Vale_InsMem.krml .output/X64_Vale_InsVector.krml .output/X64_Stack.krml .output/Workarounds.krml .output/SHA_helpers.krml .output/X64_Vale_InsSha.krml .output/X64_SHA.krml .output/Vale_sha_update_bytes_stdcall.krml .output/Interop_assumptions.krml .output/Sha_update_bytes_stdcall.krml .output/LowStar_ImmutableBuffer.krml .output/Hacl_Hash_Core_SHA2_Constants.krml .output/LowStar_Modifies_Linear.krml .output/Hacl_Hash_Core_SHA2.krml .output/Hacl_Hash_SHA2.krml .output/Hacl_Hash_Core_SHA1.krml .output/Hacl_Hash_SHA1.krml .output/Hacl_Hash_Core_MD5.krml .output/Hacl_Hash_MD5.krml .output/C.krml .output/C_String.krml .output/C_Failure.krml .output/FStar_Int128.krml .output/FStar_Int31.krml .output/FStar_UInt31.krml .output/FStar_Integers.krml .output/EverCrypt_StaticConfig.krml .output/Vale_check_sha_stdcall.krml .output/Check_sha_stdcall.krml .output/Check_aesni_stdcall.krml .output/EverCrypt_AutoConfig2.krml .output/EverCrypt_Helpers.krml .output/EverCrypt_Hash.krml .output/FStar_Dyn.krml .output/EverCrypt_Vale.krml .output/EverCrypt_Specs.krml .output/EverCrypt_OpenSSL.krml .output/EverCrypt_Hacl.krml .output/EverCrypt_BCrypt.krml .output/EverCrypt.krml .output/EverCrypt_HMAC.krml .output/EverCrypt_HKDF.krml .output/EverCrypt_Hash_Incremental.krml .output/FStar_Bytes.krml .output/EverCrypt_Bytes.krml -warn-error -6@9 -add-include "kremlib.h" -add-include "kremlin/internal/compat.h" evercrypt_vale_stubs.c -bundle X64.*,Arch.*,Words.*,Vale.*,Collections.*,Collections,SHA_helpers -bundle Prop_s,Types_s,Words_s,Views,AES_s,Workarounds,Math.*,Interop,TypesNative_s -bundle EverCrypt.Spec.* -bundle LowStar.* -bundle Prims,FStar.*,C,C.*[rename=EverCrypt_Kremlib] -bundle Hacl.*,Spec.*[rename=Hacl] -library Hacl.* -bundle Check_aesni_stdcall,Check_sha_stdcall,Sha_update_bytes_stdcall[rename=Vale] -bundle EverCrypt.BCrypt -bundle EverCrypt.OpenSSL -library EverCrypt.Bytes,EverCrypt.AutoConfig,EverCrypt.OpenSSL,EverCrypt.BCrypt -no-prefix EverCrypt.Vale -no-prefix Sha_update_bytes_stdcall -no-prefix Check_sha_stdcall -no-prefix Check_aesni_stdcall -library Sha_update_bytes_stdcall -library Check_sha_stdcall -library Check_aesni_stdcall -fparentheses -fno-shadow -fcurly-braces -o libevercrypt.a -bundle EverCrypt.Hash= -bundle EverCrypt.AutoConfig2= -bundle EverCrypt= -bundle EverCrypt.Hacl -bundle EverCrypt.OpenSSL -bundle EverCrypt.BCrypt -bundle \*[rename=EverCrypt_Misc]
 * F* version: ebf0a2cc
 * KreMLin version: e9a42a80
 */

#include "EverCrypt_Hash.h"

#define EverCrypt_Hash_such_a_bad_hack(X) (X)

void EverCrypt_Hash_bad_hack()
{
  
}

C_String_t EverCrypt_Hash_string_of_alg(Spec_Hash_Definitions_hash_alg uu___169_21)
{
  switch (uu___169_21)
  {
    case Spec_Hash_Definitions_MD5:
      {
        return "MD5";
      }
    case Spec_Hash_Definitions_SHA1:
      {
        return "SHA1";
      }
    case Spec_Hash_Definitions_SHA2_224:
      {
        return "SHA2_224";
      }
    case Spec_Hash_Definitions_SHA2_256:
      {
        return "SHA2_256";
      }
    case Spec_Hash_Definitions_SHA2_384:
      {
        return "SHA2_384";
      }
    case Spec_Hash_Definitions_SHA2_512:
      {
        return "SHA2_512";
      }
    default:
      {
        KRML_HOST_PRINTF("KreMLin incomplete match at %s:%d\n", __FILE__, __LINE__);
        KRML_HOST_EXIT(253U);
      }
  }
}

uint32_t EverCrypt_Hash_tagLen(Spec_Hash_Definitions_hash_alg a)
{
  switch (a)
  {
    case Spec_Hash_Definitions_MD5:
      {
        return (uint32_t)16U;
      }
    case Spec_Hash_Definitions_SHA1:
      {
        return (uint32_t)20U;
      }
    case Spec_Hash_Definitions_SHA2_224:
      {
        return (uint32_t)28U;
      }
    case Spec_Hash_Definitions_SHA2_256:
      {
        return (uint32_t)32U;
      }
    case Spec_Hash_Definitions_SHA2_384:
      {
        return (uint32_t)48U;
      }
    case Spec_Hash_Definitions_SHA2_512:
      {
        return (uint32_t)64U;
      }
    default:
      {
        KRML_HOST_PRINTF("KreMLin incomplete match at %s:%d\n", __FILE__, __LINE__);
        KRML_HOST_EXIT(253U);
      }
  }
}

uint32_t EverCrypt_Hash_blockLen(Spec_Hash_Definitions_hash_alg a)
{
  switch (a)
  {
    case Spec_Hash_Definitions_MD5:
      {
        return (uint32_t)64U;
      }
    case Spec_Hash_Definitions_SHA1:
      {
        return (uint32_t)64U;
      }
    case Spec_Hash_Definitions_SHA2_224:
      {
        return (uint32_t)64U;
      }
    case Spec_Hash_Definitions_SHA2_256:
      {
        return (uint32_t)64U;
      }
    case Spec_Hash_Definitions_SHA2_384:
      {
        return (uint32_t)128U;
      }
    case Spec_Hash_Definitions_SHA2_512:
      {
        return (uint32_t)128U;
      }
    default:
      {
        KRML_HOST_PRINTF("KreMLin incomplete match at %s:%d\n", __FILE__, __LINE__);
        KRML_HOST_EXIT(253U);
      }
  }
}

bool
EverCrypt_Hash_uu___is_MD5_s(
  Spec_Hash_Definitions_hash_alg uu____340,
  EverCrypt_Hash_state_s projectee
)
{
  if (projectee.tag == EverCrypt_Hash_MD5_s)
  {
    return true;
  }
  else
  {
    return false;
  }
}

uint32_t
*EverCrypt_Hash___proj__MD5_s__item__p(
  Spec_Hash_Definitions_hash_alg uu____398,
  EverCrypt_Hash_state_s projectee
)
{
  if (projectee.tag == EverCrypt_Hash_MD5_s)
  {
    return projectee.case_MD5_s;
  }
  else
  {
    KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool
EverCrypt_Hash_uu___is_SHA1_s(
  Spec_Hash_Definitions_hash_alg uu____426,
  EverCrypt_Hash_state_s projectee
)
{
  if (projectee.tag == EverCrypt_Hash_SHA1_s)
  {
    return true;
  }
  else
  {
    return false;
  }
}

uint32_t
*EverCrypt_Hash___proj__SHA1_s__item__p(
  Spec_Hash_Definitions_hash_alg uu____484,
  EverCrypt_Hash_state_s projectee
)
{
  if (projectee.tag == EverCrypt_Hash_SHA1_s)
  {
    return projectee.case_SHA1_s;
  }
  else
  {
    KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool
EverCrypt_Hash_uu___is_SHA2_224_s(
  Spec_Hash_Definitions_hash_alg uu____512,
  EverCrypt_Hash_state_s projectee
)
{
  if (projectee.tag == EverCrypt_Hash_SHA2_224_s)
  {
    return true;
  }
  else
  {
    return false;
  }
}

uint32_t
*EverCrypt_Hash___proj__SHA2_224_s__item__p(
  Spec_Hash_Definitions_hash_alg uu____570,
  EverCrypt_Hash_state_s projectee
)
{
  if (projectee.tag == EverCrypt_Hash_SHA2_224_s)
  {
    return projectee.case_SHA2_224_s;
  }
  else
  {
    KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool
EverCrypt_Hash_uu___is_SHA2_256_s(
  Spec_Hash_Definitions_hash_alg uu____598,
  EverCrypt_Hash_state_s projectee
)
{
  if (projectee.tag == EverCrypt_Hash_SHA2_256_s)
  {
    return true;
  }
  else
  {
    return false;
  }
}

uint32_t
*EverCrypt_Hash___proj__SHA2_256_s__item__p(
  Spec_Hash_Definitions_hash_alg uu____656,
  EverCrypt_Hash_state_s projectee
)
{
  if (projectee.tag == EverCrypt_Hash_SHA2_256_s)
  {
    return projectee.case_SHA2_256_s;
  }
  else
  {
    KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool
EverCrypt_Hash_uu___is_SHA2_384_s(
  Spec_Hash_Definitions_hash_alg uu____684,
  EverCrypt_Hash_state_s projectee
)
{
  if (projectee.tag == EverCrypt_Hash_SHA2_384_s)
  {
    return true;
  }
  else
  {
    return false;
  }
}

uint64_t
*EverCrypt_Hash___proj__SHA2_384_s__item__p(
  Spec_Hash_Definitions_hash_alg uu____742,
  EverCrypt_Hash_state_s projectee
)
{
  if (projectee.tag == EverCrypt_Hash_SHA2_384_s)
  {
    return projectee.case_SHA2_384_s;
  }
  else
  {
    KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool
EverCrypt_Hash_uu___is_SHA2_512_s(
  Spec_Hash_Definitions_hash_alg uu____770,
  EverCrypt_Hash_state_s projectee
)
{
  if (projectee.tag == EverCrypt_Hash_SHA2_512_s)
  {
    return true;
  }
  else
  {
    return false;
  }
}

uint64_t
*EverCrypt_Hash___proj__SHA2_512_s__item__p(
  Spec_Hash_Definitions_hash_alg uu____828,
  EverCrypt_Hash_state_s projectee
)
{
  if (projectee.tag == EverCrypt_Hash_SHA2_512_s)
  {
    return projectee.case_SHA2_512_s;
  }
  else
  {
    KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

EverCrypt_Hash_state_s *EverCrypt_Hash_create_in(Spec_Hash_Definitions_hash_alg a)
{
  EverCrypt_Hash_state_s s;
  switch (a)
  {
    case Spec_Hash_Definitions_MD5:
      {
        uint32_t *buf = KRML_HOST_CALLOC((uint32_t)4U, sizeof (uint32_t));
        s = ((EverCrypt_Hash_state_s){ .tag = EverCrypt_Hash_MD5_s, { .case_MD5_s = buf } });
        break;
      }
    case Spec_Hash_Definitions_SHA1:
      {
        uint32_t *buf = KRML_HOST_CALLOC((uint32_t)5U, sizeof (uint32_t));
        s = ((EverCrypt_Hash_state_s){ .tag = EverCrypt_Hash_SHA1_s, { .case_SHA1_s = buf } });
        break;
      }
    case Spec_Hash_Definitions_SHA2_224:
      {
        uint32_t *buf = KRML_HOST_CALLOC((uint32_t)8U, sizeof (uint32_t));
        s =
          ((EverCrypt_Hash_state_s){ .tag = EverCrypt_Hash_SHA2_224_s, { .case_SHA2_224_s = buf } });
        break;
      }
    case Spec_Hash_Definitions_SHA2_256:
      {
        uint32_t *buf = KRML_HOST_CALLOC((uint32_t)8U, sizeof (uint32_t));
        s =
          ((EverCrypt_Hash_state_s){ .tag = EverCrypt_Hash_SHA2_256_s, { .case_SHA2_256_s = buf } });
        break;
      }
    case Spec_Hash_Definitions_SHA2_384:
      {
        uint64_t *buf = KRML_HOST_CALLOC((uint32_t)8U, sizeof (uint64_t));
        s =
          ((EverCrypt_Hash_state_s){ .tag = EverCrypt_Hash_SHA2_384_s, { .case_SHA2_384_s = buf } });
        break;
      }
    case Spec_Hash_Definitions_SHA2_512:
      {
        uint64_t *buf = KRML_HOST_CALLOC((uint32_t)8U, sizeof (uint64_t));
        s =
          ((EverCrypt_Hash_state_s){ .tag = EverCrypt_Hash_SHA2_512_s, { .case_SHA2_512_s = buf } });
        break;
      }
    default:
      {
        KRML_HOST_PRINTF("KreMLin incomplete match at %s:%d\n", __FILE__, __LINE__);
        KRML_HOST_EXIT(253U);
      }
  }
  KRML_CHECK_SIZE(sizeof (EverCrypt_Hash_state_s), (uint32_t)1U);
  EverCrypt_Hash_state_s *buf = KRML_HOST_MALLOC(sizeof (EverCrypt_Hash_state_s));
  buf[0U] = s;
  return buf;
}

EverCrypt_Hash_state_s *EverCrypt_Hash_create(Spec_Hash_Definitions_hash_alg a)
{
  return EverCrypt_Hash_create_in(a);
}

void EverCrypt_Hash_init(EverCrypt_Hash_state_s *s)
{
  EverCrypt_Hash_state_s scrut = *s;
  if (scrut.tag == EverCrypt_Hash_MD5_s)
  {
    uint32_t *p1 = scrut.case_MD5_s;
    Hacl_Hash_Core_MD5_init(p1);
  }
  else
  {
    if (scrut.tag == EverCrypt_Hash_SHA1_s)
    {
      uint32_t *p1 = scrut.case_SHA1_s;
      Hacl_Hash_Core_SHA1_init(p1);
    }
    else
    {
      if (scrut.tag == EverCrypt_Hash_SHA2_224_s)
      {
        uint32_t *p1 = scrut.case_SHA2_224_s;
        Hacl_Hash_Core_SHA2_init_224(p1);
      }
      else
      {
        if (scrut.tag == EverCrypt_Hash_SHA2_256_s)
        {
          uint32_t *p1 = scrut.case_SHA2_256_s;
          Hacl_Hash_Core_SHA2_init_256(p1);
        }
        else
        {
          if (scrut.tag == EverCrypt_Hash_SHA2_384_s)
          {
            uint64_t *p1 = scrut.case_SHA2_384_s;
            Hacl_Hash_Core_SHA2_init_384(p1);
          }
          else
          {
            if (scrut.tag == EverCrypt_Hash_SHA2_512_s)
            {
              uint64_t *p1 = scrut.case_SHA2_512_s;
              Hacl_Hash_Core_SHA2_init_512(p1);
            }
            else
            {
              KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
                __FILE__,
                __LINE__,
                "unreachable (pattern matches are exhaustive in F*)");
              KRML_HOST_EXIT(255U);
            }
          }
        }
      }
    }
  }
}

void EverCrypt_Hash_update(EverCrypt_Hash_state_s *s, uint8_t *block)
{
  EverCrypt_Hash_state_s scrut = *s;
  if (scrut.tag == EverCrypt_Hash_MD5_s)
  {
    uint32_t *p1 = scrut.case_MD5_s;
    Hacl_Hash_Core_MD5_update(p1, block);
  }
  else
  {
    if (scrut.tag == EverCrypt_Hash_SHA1_s)
    {
      uint32_t *p1 = scrut.case_SHA1_s;
      Hacl_Hash_Core_SHA1_update(p1, block);
    }
    else
    {
      if (scrut.tag == EverCrypt_Hash_SHA2_224_s)
      {
        uint32_t *p1 = scrut.case_SHA2_224_s;
        Hacl_Hash_Core_SHA2_update_224(p1, block);
      }
      else
      {
        if (scrut.tag == EverCrypt_Hash_SHA2_256_s)
        {
          uint32_t *p1 = scrut.case_SHA2_256_s;
          bool has_shaext1 = EverCrypt_AutoConfig2_has_shaext();
          if (true && has_shaext1)
          {
            uint64_t n1 = (uint64_t)(uint32_t)1U;
            uint32_t *k1 = EverCrypt_Hash_such_a_bad_hack(Hacl_Hash_Core_SHA2_Constants_k224_256);
            sha256_update(p1, block, n1, k1);
          }
          else
          {
            Hacl_Hash_SHA2_update_multi_256(p1, block, (uint32_t)1U);
          }
        }
        else
        {
          if (scrut.tag == EverCrypt_Hash_SHA2_384_s)
          {
            uint64_t *p1 = scrut.case_SHA2_384_s;
            Hacl_Hash_Core_SHA2_update_384(p1, block);
          }
          else
          {
            if (scrut.tag == EverCrypt_Hash_SHA2_512_s)
            {
              uint64_t *p1 = scrut.case_SHA2_512_s;
              Hacl_Hash_Core_SHA2_update_512(p1, block);
            }
            else
            {
              KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
                __FILE__,
                __LINE__,
                "unreachable (pattern matches are exhaustive in F*)");
              KRML_HOST_EXIT(255U);
            }
          }
        }
      }
    }
  }
}

void EverCrypt_Hash_update_multi(EverCrypt_Hash_state_s *s, uint8_t *blocks, uint32_t len1)
{
  EverCrypt_Hash_state_s scrut = *s;
  if (scrut.tag == EverCrypt_Hash_MD5_s)
  {
    uint32_t *p1 = scrut.case_MD5_s;
    uint32_t n1 = len1 / (uint32_t)64U;
    Hacl_Hash_MD5_update_multi(p1, blocks, n1);
  }
  else
  {
    if (scrut.tag == EverCrypt_Hash_SHA1_s)
    {
      uint32_t *p1 = scrut.case_SHA1_s;
      uint32_t n1 = len1 / (uint32_t)64U;
      Hacl_Hash_SHA1_update_multi(p1, blocks, n1);
    }
    else
    {
      if (scrut.tag == EverCrypt_Hash_SHA2_224_s)
      {
        uint32_t *p1 = scrut.case_SHA2_224_s;
        uint32_t n1 = len1 / (uint32_t)64U;
        Hacl_Hash_SHA2_update_multi_224(p1, blocks, n1);
      }
      else
      {
        if (scrut.tag == EverCrypt_Hash_SHA2_256_s)
        {
          uint32_t *p1 = scrut.case_SHA2_256_s;
          uint32_t n1 = len1 / (uint32_t)64U;
          bool has_shaext1 = EverCrypt_AutoConfig2_has_shaext();
          if (true && has_shaext1)
          {
            uint64_t n2 = (uint64_t)n1;
            uint32_t *k1 = EverCrypt_Hash_such_a_bad_hack(Hacl_Hash_Core_SHA2_Constants_k224_256);
            sha256_update(p1, blocks, n2, k1);
          }
          else
          {
            Hacl_Hash_SHA2_update_multi_256(p1, blocks, n1);
          }
        }
        else
        {
          if (scrut.tag == EverCrypt_Hash_SHA2_384_s)
          {
            uint64_t *p1 = scrut.case_SHA2_384_s;
            uint32_t n1 = len1 / (uint32_t)128U;
            Hacl_Hash_SHA2_update_multi_384(p1, blocks, n1);
          }
          else
          {
            if (scrut.tag == EverCrypt_Hash_SHA2_512_s)
            {
              uint64_t *p1 = scrut.case_SHA2_512_s;
              uint32_t n1 = len1 / (uint32_t)128U;
              Hacl_Hash_SHA2_update_multi_512(p1, blocks, n1);
            }
            else
            {
              KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
                __FILE__,
                __LINE__,
                "unreachable (pattern matches are exhaustive in F*)");
              KRML_HOST_EXIT(255U);
            }
          }
        }
      }
    }
  }
}

static void
EverCrypt_Hash_update_last_256(
  uint32_t *s,
  uint64_t prev_len,
  uint8_t *input,
  uint32_t input_len
)
{
  uint32_t blocks_n = input_len / (uint32_t)64U;
  uint32_t blocks_len = blocks_n * (uint32_t)64U;
  uint8_t *blocks = input;
  uint32_t rest_len = input_len - blocks_len;
  uint8_t *rest = input + blocks_len;
  bool has_shaext1 = EverCrypt_AutoConfig2_has_shaext();
  if (true && has_shaext1)
  {
    uint64_t n1 = (uint64_t)blocks_n;
    uint32_t *k1 = EverCrypt_Hash_such_a_bad_hack(Hacl_Hash_Core_SHA2_Constants_k224_256);
    sha256_update(s, blocks, n1, k1);
  }
  else
  {
    Hacl_Hash_SHA2_update_multi_256(s, blocks, blocks_n);
  }
  uint64_t total_input_len = prev_len + (uint64_t)input_len;
  uint32_t
  pad_len1 =
    (uint32_t)1U
    +
      ((uint32_t)128U - ((uint32_t)9U + (uint32_t)(total_input_len % (uint64_t)(uint32_t)64U)))
      % (uint32_t)64U
    + (uint32_t)8U;
  uint32_t tmp_len = rest_len + pad_len1;
  uint8_t tmp_twoblocks[128U] = { 0U };
  uint8_t *tmp = tmp_twoblocks;
  uint8_t *tmp_rest = tmp;
  uint8_t *tmp_pad = tmp + rest_len;
  memcpy(tmp_rest, rest, rest_len * sizeof rest[0U]);
  Hacl_Hash_Core_SHA2_pad_256(total_input_len, tmp_pad);
  bool has_shaext10 = EverCrypt_AutoConfig2_has_shaext();
  if (true && has_shaext10)
  {
    uint64_t n1 = (uint64_t)(tmp_len / (uint32_t)64U);
    uint32_t *k1 = EverCrypt_Hash_such_a_bad_hack(Hacl_Hash_Core_SHA2_Constants_k224_256);
    sha256_update(s, tmp, n1, k1);
  }
  else
  {
    Hacl_Hash_SHA2_update_multi_256(s, tmp, tmp_len / (uint32_t)64U);
  }
}

void EverCrypt_Hash_update_last(EverCrypt_Hash_state_s *s, uint8_t *last1, uint64_t total_len)
{
  EverCrypt_Hash_state_s scrut = *s;
  if (scrut.tag == EverCrypt_Hash_MD5_s)
  {
    uint32_t *p1 = scrut.case_MD5_s;
    uint64_t input_len = total_len % (uint64_t)(uint32_t)64U;
    uint64_t prev_len = total_len - input_len;
    Hacl_Hash_MD5_update_last(p1, prev_len, last1, (uint32_t)input_len);
  }
  else
  {
    if (scrut.tag == EverCrypt_Hash_SHA1_s)
    {
      uint32_t *p1 = scrut.case_SHA1_s;
      uint64_t input_len = total_len % (uint64_t)(uint32_t)64U;
      uint64_t prev_len = total_len - input_len;
      Hacl_Hash_SHA1_update_last(p1, prev_len, last1, (uint32_t)input_len);
    }
    else
    {
      if (scrut.tag == EverCrypt_Hash_SHA2_224_s)
      {
        uint32_t *p1 = scrut.case_SHA2_224_s;
        uint64_t input_len = total_len % (uint64_t)(uint32_t)64U;
        uint64_t prev_len = total_len - input_len;
        Hacl_Hash_SHA2_update_last_224(p1, prev_len, last1, (uint32_t)input_len);
      }
      else
      {
        if (scrut.tag == EverCrypt_Hash_SHA2_256_s)
        {
          uint32_t *p1 = scrut.case_SHA2_256_s;
          uint64_t input_len = total_len % (uint64_t)(uint32_t)64U;
          uint64_t prev_len = total_len - input_len;
          EverCrypt_Hash_update_last_256(p1, prev_len, last1, (uint32_t)input_len);
        }
        else
        {
          if (scrut.tag == EverCrypt_Hash_SHA2_384_s)
          {
            uint64_t *p1 = scrut.case_SHA2_384_s;
            uint64_t input_len = total_len % (uint64_t)(uint32_t)128U;
            FStar_UInt128_uint128
            prev_len = FStar_Int_Cast_Full_uint64_to_uint128(total_len - input_len);
            Hacl_Hash_SHA2_update_last_384(p1, prev_len, last1, (uint32_t)input_len);
          }
          else
          {
            if (scrut.tag == EverCrypt_Hash_SHA2_512_s)
            {
              uint64_t *p1 = scrut.case_SHA2_512_s;
              uint64_t input_len = total_len % (uint64_t)(uint32_t)128U;
              FStar_UInt128_uint128
              prev_len = FStar_Int_Cast_Full_uint64_to_uint128(total_len - input_len);
              Hacl_Hash_SHA2_update_last_512(p1, prev_len, last1, (uint32_t)input_len);
            }
            else
            {
              KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
                __FILE__,
                __LINE__,
                "unreachable (pattern matches are exhaustive in F*)");
              KRML_HOST_EXIT(255U);
            }
          }
        }
      }
    }
  }
}

void EverCrypt_Hash_finish(EverCrypt_Hash_state_s *s, uint8_t *dst)
{
  EverCrypt_Hash_state_s scrut = *s;
  if (scrut.tag == EverCrypt_Hash_MD5_s)
  {
    uint32_t *p1 = scrut.case_MD5_s;
    Hacl_Hash_Core_MD5_finish(p1, dst);
  }
  else
  {
    if (scrut.tag == EverCrypt_Hash_SHA1_s)
    {
      uint32_t *p1 = scrut.case_SHA1_s;
      Hacl_Hash_Core_SHA1_finish(p1, dst);
    }
    else
    {
      if (scrut.tag == EverCrypt_Hash_SHA2_224_s)
      {
        uint32_t *p1 = scrut.case_SHA2_224_s;
        Hacl_Hash_Core_SHA2_finish_224(p1, dst);
      }
      else
      {
        if (scrut.tag == EverCrypt_Hash_SHA2_256_s)
        {
          uint32_t *p1 = scrut.case_SHA2_256_s;
          Hacl_Hash_Core_SHA2_finish_256(p1, dst);
        }
        else
        {
          if (scrut.tag == EverCrypt_Hash_SHA2_384_s)
          {
            uint64_t *p1 = scrut.case_SHA2_384_s;
            Hacl_Hash_Core_SHA2_finish_384(p1, dst);
          }
          else
          {
            if (scrut.tag == EverCrypt_Hash_SHA2_512_s)
            {
              uint64_t *p1 = scrut.case_SHA2_512_s;
              Hacl_Hash_Core_SHA2_finish_512(p1, dst);
            }
            else
            {
              KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
                __FILE__,
                __LINE__,
                "unreachable (pattern matches are exhaustive in F*)");
              KRML_HOST_EXIT(255U);
            }
          }
        }
      }
    }
  }
}

void EverCrypt_Hash_free(EverCrypt_Hash_state_s *s)
{
  EverCrypt_Hash_state_s scrut = *s;
  if (scrut.tag == EverCrypt_Hash_MD5_s)
  {
    uint32_t *p1 = scrut.case_MD5_s;
    KRML_HOST_FREE(p1);
  }
  else
  {
    if (scrut.tag == EverCrypt_Hash_SHA1_s)
    {
      uint32_t *p1 = scrut.case_SHA1_s;
      KRML_HOST_FREE(p1);
    }
    else
    {
      if (scrut.tag == EverCrypt_Hash_SHA2_224_s)
      {
        uint32_t *p1 = scrut.case_SHA2_224_s;
        KRML_HOST_FREE(p1);
      }
      else
      {
        if (scrut.tag == EverCrypt_Hash_SHA2_256_s)
        {
          uint32_t *p1 = scrut.case_SHA2_256_s;
          KRML_HOST_FREE(p1);
        }
        else
        {
          if (scrut.tag == EverCrypt_Hash_SHA2_384_s)
          {
            uint64_t *p1 = scrut.case_SHA2_384_s;
            KRML_HOST_FREE(p1);
          }
          else
          {
            if (scrut.tag == EverCrypt_Hash_SHA2_512_s)
            {
              uint64_t *p1 = scrut.case_SHA2_512_s;
              KRML_HOST_FREE(p1);
            }
            else
            {
              KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
                __FILE__,
                __LINE__,
                "unreachable (pattern matches are exhaustive in F*)");
              KRML_HOST_EXIT(255U);
            }
          }
        }
      }
    }
  }
  KRML_HOST_FREE(s);
}

void EverCrypt_Hash_copy(EverCrypt_Hash_state_s *s_src, EverCrypt_Hash_state_s *s_dst)
{
  EverCrypt_Hash_state_s scrut = *s_src;
  if (scrut.tag == EverCrypt_Hash_MD5_s)
  {
    uint32_t *p_src = scrut.case_MD5_s;
    EverCrypt_Hash_state_s x1 = *s_dst;
    uint32_t *p_dst;
    if (x1.tag == EverCrypt_Hash_MD5_s)
    {
      p_dst = x1.case_MD5_s;
    }
    else
    {
      p_dst = KRML_EABORT(uint32_t *, "unreachable (pattern matches are exhaustive in F*)");
    }
    memcpy(p_dst, p_src, (uint32_t)4U * sizeof p_src[0U]);
  }
  else
  {
    if (scrut.tag == EverCrypt_Hash_SHA1_s)
    {
      uint32_t *p_src = scrut.case_SHA1_s;
      EverCrypt_Hash_state_s x1 = *s_dst;
      uint32_t *p_dst;
      if (x1.tag == EverCrypt_Hash_SHA1_s)
      {
        p_dst = x1.case_SHA1_s;
      }
      else
      {
        p_dst = KRML_EABORT(uint32_t *, "unreachable (pattern matches are exhaustive in F*)");
      }
      memcpy(p_dst, p_src, (uint32_t)5U * sizeof p_src[0U]);
    }
    else
    {
      if (scrut.tag == EverCrypt_Hash_SHA2_224_s)
      {
        uint32_t *p_src = scrut.case_SHA2_224_s;
        EverCrypt_Hash_state_s x1 = *s_dst;
        uint32_t *p_dst;
        if (x1.tag == EverCrypt_Hash_SHA2_224_s)
        {
          p_dst = x1.case_SHA2_224_s;
        }
        else
        {
          p_dst = KRML_EABORT(uint32_t *, "unreachable (pattern matches are exhaustive in F*)");
        }
        memcpy(p_dst, p_src, (uint32_t)8U * sizeof p_src[0U]);
      }
      else
      {
        if (scrut.tag == EverCrypt_Hash_SHA2_256_s)
        {
          uint32_t *p_src = scrut.case_SHA2_256_s;
          EverCrypt_Hash_state_s x1 = *s_dst;
          uint32_t *p_dst;
          if (x1.tag == EverCrypt_Hash_SHA2_256_s)
          {
            p_dst = x1.case_SHA2_256_s;
          }
          else
          {
            p_dst = KRML_EABORT(uint32_t *, "unreachable (pattern matches are exhaustive in F*)");
          }
          memcpy(p_dst, p_src, (uint32_t)8U * sizeof p_src[0U]);
        }
        else
        {
          if (scrut.tag == EverCrypt_Hash_SHA2_384_s)
          {
            uint64_t *p_src = scrut.case_SHA2_384_s;
            EverCrypt_Hash_state_s x1 = *s_dst;
            uint64_t *p_dst;
            if (x1.tag == EverCrypt_Hash_SHA2_384_s)
            {
              p_dst = x1.case_SHA2_384_s;
            }
            else
            {
              p_dst = KRML_EABORT(uint64_t *, "unreachable (pattern matches are exhaustive in F*)");
            }
            memcpy(p_dst, p_src, (uint32_t)8U * sizeof p_src[0U]);
          }
          else
          {
            if (scrut.tag == EverCrypt_Hash_SHA2_512_s)
            {
              uint64_t *p_src = scrut.case_SHA2_512_s;
              EverCrypt_Hash_state_s x1 = *s_dst;
              uint64_t *p_dst;
              if (x1.tag == EverCrypt_Hash_SHA2_512_s)
              {
                p_dst = x1.case_SHA2_512_s;
              }
              else
              {
                p_dst =
                  KRML_EABORT(uint64_t *,
                    "unreachable (pattern matches are exhaustive in F*)");
              }
              memcpy(p_dst, p_src, (uint32_t)8U * sizeof p_src[0U]);
            }
            else
            {
              KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
                __FILE__,
                __LINE__,
                "unreachable (pattern matches are exhaustive in F*)");
              KRML_HOST_EXIT(255U);
            }
          }
        }
      }
    }
  }
}

static void EverCrypt_Hash_hash_256(uint8_t *input, uint32_t input_len, uint8_t *dst)
{
  uint32_t
  s[8U] =
    {
      (uint32_t)0x6a09e667U, (uint32_t)0xbb67ae85U, (uint32_t)0x3c6ef372U, (uint32_t)0xa54ff53aU,
      (uint32_t)0x510e527fU, (uint32_t)0x9b05688cU, (uint32_t)0x1f83d9abU, (uint32_t)0x5be0cd19U
    };
  uint32_t blocks_n = input_len / (uint32_t)64U;
  uint32_t blocks_len = blocks_n * (uint32_t)64U;
  uint8_t *blocks = input;
  uint32_t rest_len = input_len - blocks_len;
  uint8_t *rest = input + blocks_len;
  Hacl_Hash_SHA2_update_multi_256(s, blocks, blocks_n);
  Hacl_Hash_SHA2_update_last_256(s, (uint64_t)blocks_len, rest, rest_len);
  Hacl_Hash_Core_SHA2_finish_256(s, dst);
}

void
EverCrypt_Hash_hash(
  Spec_Hash_Definitions_hash_alg a,
  uint8_t *dst,
  uint8_t *input,
  uint32_t len1
)
{
  switch (a)
  {
    case Spec_Hash_Definitions_MD5:
      {
        Hacl_Hash_MD5_hash(input, len1, dst);
        break;
      }
    case Spec_Hash_Definitions_SHA1:
      {
        Hacl_Hash_SHA1_hash(input, len1, dst);
        break;
      }
    case Spec_Hash_Definitions_SHA2_224:
      {
        Hacl_Hash_SHA2_hash_224(input, len1, dst);
        break;
      }
    case Spec_Hash_Definitions_SHA2_256:
      {
        EverCrypt_Hash_hash_256(input, len1, dst);
        break;
      }
    case Spec_Hash_Definitions_SHA2_384:
      {
        Hacl_Hash_SHA2_hash_384(input, len1, dst);
        break;
      }
    case Spec_Hash_Definitions_SHA2_512:
      {
        Hacl_Hash_SHA2_hash_512(input, len1, dst);
        break;
      }
    default:
      {
        KRML_HOST_PRINTF("KreMLin incomplete match at %s:%d\n", __FILE__, __LINE__);
        KRML_HOST_EXIT(253U);
      }
  }
}

