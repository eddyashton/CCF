/* This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
 * KreMLin invocation: /mnt/e/everest/verify/kremlin/krml -skip-compilation -minimal -tmpdir dist/ccf/ .output/prims.krml .output/FStar_Pervasives_Native.krml .output/FStar_Pervasives.krml .output/FStar_Mul.krml .output/FStar_Squash.krml .output/FStar_Classical.krml .output/FStar_StrongExcludedMiddle.krml .output/FStar_FunctionalExtensionality.krml .output/FStar_List_Tot_Base.krml .output/FStar_List_Tot_Properties.krml .output/FStar_List_Tot.krml .output/FStar_Seq_Base.krml .output/FStar_Seq_Properties.krml .output/FStar_Seq.krml .output/FStar_Math_Lib.krml .output/FStar_Math_Lemmas.krml .output/FStar_BitVector.krml .output/FStar_UInt.krml .output/FStar_UInt32.krml .output/FStar_Int.krml .output/FStar_Int16.krml .output/Opaque_s.krml .output/Collections_Seqs_s.krml .output/FStar_UInt8.krml .output/Words_s.krml .output/Words_Four_s.krml .output/Words_Two_s.krml .output/Words_Seq_s.krml .output/Types_s.krml .output/TypesNative_s.krml .output/Arch_TypesNative.krml .output/Prop_s.krml .output/Util_Meta.krml .output/FStar_Set.krml .output/FStar_Map.krml .output/X64_Machine_s.krml .output/X64_CPU_Features_s.krml .output/Map16.krml .output/X64_Vale_Xmms.krml .output/X64_Vale_Regs.krml .output/FStar_Float.krml .output/FStar_UInt64.krml .output/FStar_Exn.krml .output/FStar_Preorder.krml .output/FStar_Monotonic_Witnessed.krml .output/FStar_Ghost.krml .output/FStar_ErasedLogic.krml .output/FStar_PropositionalExtensionality.krml .output/FStar_PredicateExtensionality.krml .output/FStar_TSet.krml .output/FStar_Monotonic_Heap.krml .output/FStar_Heap.krml .output/FStar_ST.krml .output/FStar_All.krml .output/FStar_IO.krml .output/Words_Two.krml .output/Collections_Seqs.krml .output/Words_Seq.krml .output/Arch_Types.krml .output/AES_s.krml .output/Math_Poly2_Defs_s.krml .output/Math_Poly2_s.krml .output/Math_Poly2_Bits_s.krml .output/FStar_Monotonic_HyperHeap.krml .output/FStar_Monotonic_HyperStack.krml .output/FStar_HyperStack.krml .output/FStar_HyperStack_ST.krml .output/FStar_HyperStack_All.krml .output/FStar_Kremlin_Endianness.krml .output/FStar_Int64.krml .output/FStar_Int63.krml .output/FStar_Int32.krml .output/FStar_Int8.krml .output/FStar_UInt63.krml .output/FStar_UInt16.krml .output/FStar_Int_Cast.krml .output/FStar_UInt128.krml .output/Spec_Hash_Definitions.krml .output/Spec_Hash_Lemmas0.krml .output/Spec_Hash_PadFinish.krml .output/Spec_Loops.krml .output/FStar_List.krml .output/Spec_SHA2_Constants.krml .output/Spec_SHA2.krml .output/X64_CryptoInstructions_s.krml .output/X64_Bytes_Semantics_s.krml .output/FStar_Char.krml .output/FStar_BaseTypes.krml .output/X64_Taint_Semantics_s.krml .output/X64_Bytes_Semantics.krml .output/FStar_Universe.krml .output/FStar_GSet.krml .output/FStar_ModifiesGen.krml .output/FStar_Range.krml .output/FStar_Reflection_Types.krml .output/FStar_Tactics_Types.krml .output/FStar_Tactics_Result.krml .output/FStar_Tactics_Effect.krml .output/FStar_Tactics_Util.krml .output/FStar_Reflection_Data.krml .output/FStar_Reflection_Const.krml .output/FStar_String.krml .output/FStar_Order.krml .output/FStar_Reflection_Basic.krml .output/FStar_Reflection_Derived.krml .output/FStar_Tactics_Builtins.krml .output/FStar_Reflection_Formula.krml .output/FStar_Reflection_Derived_Lemmas.krml .output/FStar_Reflection.krml .output/FStar_Tactics_Derived.krml .output/FStar_Tactics_Logic.krml .output/FStar_Tactics.krml .output/FStar_BigOps.krml .output/LowStar_Monotonic_Buffer.krml .output/LowStar_BufferView.krml .output/Views.krml .output/LowStar_Buffer.krml .output/LowStar_Modifies.krml .output/LowStar_ModifiesPat.krml .output/Interop.krml .output/X64_Memory.krml .output/BufferViewHelpers.krml .output/X64_BufferViewStore.krml .output/X64_Memory_Sems.krml .output/X64_Vale_State.krml .output/X64_Vale_StateLemmas.krml .output/X64_Vale_Lemmas.krml .output/X64_Print_s.krml .output/X64_Vale_Decls.krml .output/X64_Vale_QuickCode.krml .output/X64_Vale_QuickCodes.krml .output/X64_Taint_Semantics.krml .output/X64_Vale_InsLemmas.krml .output/X64_Vale_InsBasic.krml .output/X64_Cpuid.krml .output/X64_Cpuidstdcall.krml .output/Vale_check_aesni_stdcall.krml .output/Spec_SHA1.krml .output/Spec_MD5.krml .output/Spec_Hash.krml .output/Spec_Hash_Incremental.krml .output/Spec_Hash_Lemmas.krml .output/LowStar_BufferOps.krml .output/C_Loops.krml .output/C_Endianness.krml .output/Hacl_Hash_Lemmas.krml .output/Hacl_Hash_Definitions.krml .output/FStar_Int_Cast_Full.krml .output/Hacl_Hash_PadFinish.krml .output/Hacl_Hash_MD.krml .output/X64_Vale_InsMem.krml .output/X64_Vale_InsVector.krml .output/X64_Stack.krml .output/Workarounds.krml .output/SHA_helpers.krml .output/X64_Vale_InsSha.krml .output/X64_SHA.krml .output/Vale_sha_update_bytes_stdcall.krml .output/Interop_assumptions.krml .output/Sha_update_bytes_stdcall.krml .output/LowStar_ImmutableBuffer.krml .output/Hacl_Hash_Core_SHA2_Constants.krml .output/LowStar_Modifies_Linear.krml .output/Hacl_Hash_Core_SHA2.krml .output/Hacl_Hash_SHA2.krml .output/Hacl_Hash_Core_SHA1.krml .output/Hacl_Hash_SHA1.krml .output/Hacl_Hash_Core_MD5.krml .output/Hacl_Hash_MD5.krml .output/C.krml .output/C_String.krml .output/C_Failure.krml .output/FStar_Int128.krml .output/FStar_Int31.krml .output/FStar_UInt31.krml .output/FStar_Integers.krml .output/EverCrypt_StaticConfig.krml .output/Vale_check_sha_stdcall.krml .output/Check_sha_stdcall.krml .output/Check_aesni_stdcall.krml .output/EverCrypt_AutoConfig2.krml .output/EverCrypt_Helpers.krml .output/EverCrypt_Hash.krml .output/FStar_Dyn.krml .output/EverCrypt_Vale.krml .output/EverCrypt_Specs.krml .output/EverCrypt_OpenSSL.krml .output/EverCrypt_Hacl.krml .output/EverCrypt_BCrypt.krml .output/EverCrypt.krml .output/EverCrypt_HMAC.krml .output/EverCrypt_HKDF.krml .output/EverCrypt_Hash_Incremental.krml .output/FStar_Bytes.krml .output/EverCrypt_Bytes.krml -warn-error -6@9 -add-include "kremlib.h" -add-include "kremlin/internal/compat.h" evercrypt_vale_stubs.c -bundle X64.*,Arch.*,Words.*,Vale.*,Collections.*,Collections,SHA_helpers -bundle Prop_s,Types_s,Words_s,Views,AES_s,Workarounds,Math.*,Interop,TypesNative_s -bundle EverCrypt.Spec.* -bundle LowStar.* -bundle Prims,FStar.*,C,C.*[rename=EverCrypt_Kremlib] -bundle Hacl.*,Spec.*[rename=Hacl] -library Hacl.* -bundle Check_aesni_stdcall,Check_sha_stdcall,Sha_update_bytes_stdcall[rename=Vale] -bundle EverCrypt.BCrypt -bundle EverCrypt.OpenSSL -library EverCrypt.Bytes,EverCrypt.AutoConfig,EverCrypt.OpenSSL,EverCrypt.BCrypt -no-prefix EverCrypt.Vale -no-prefix Sha_update_bytes_stdcall -no-prefix Check_sha_stdcall -no-prefix Check_aesni_stdcall -library Sha_update_bytes_stdcall -library Check_sha_stdcall -library Check_aesni_stdcall -fparentheses -fno-shadow -fcurly-braces -o libevercrypt.a -bundle EverCrypt.Hash= -bundle EverCrypt.AutoConfig2= -bundle EverCrypt= -bundle EverCrypt.Hacl -bundle EverCrypt.OpenSSL -bundle EverCrypt.BCrypt -bundle \*[rename=EverCrypt_Misc]
 * F* version: ebf0a2cc
 * KreMLin version: e9a42a80
 */

#include "EverCrypt.h"

static void C_Failure_failwith____(C_String_t s)
{
  C_String_print(s);
  if (C_Failure_whatever())
  {
    portable_exit((int32_t)255);
  }
  C_Failure_failwith____(s);
}

void EverCrypt_x25519(uint8_t *dst, uint8_t *secret, uint8_t *base)
{
  if (EverCrypt_AutoConfig2_wants_hacl())
  {
    EverCrypt_Hacl_x25519(dst, secret, base);
  }
  else
  {
    C_Failure_failwith____("ERROR: inconsistent configuration (x25519)");
  }
}

static uint32_t C_Failure_failwith__uint32_t(C_String_t s)
{
  C_String_print(s);
  if (C_Failure_whatever())
  {
    portable_exit((int32_t)255);
  }
  return C_Failure_failwith__uint32_t(s);
}

uint32_t EverCrypt_random_init()
{
  return C_Failure_failwith__uint32_t("ERROR: inconsistent configuration (random_init)");
}

void EverCrypt_random_sample(uint32_t len1, uint8_t *out)
{
  C_Failure_failwith____("ERROR: inconsistent configuration (random_sample)");
}

void EverCrypt_random_cleanup()
{
  C_Failure_failwith____("ERROR: inconsistent configuration (random_cleanup)");
}

typedef struct EverCrypt_aes128_key_s_s
{
  EverCrypt_aes128_key_s_tags tag;
  union {
    FStar_Dyn_dyn case_AES128_OPENSSL;
    FStar_Dyn_dyn case_AES128_BCRYPT;
    struct 
    {
      uint8_t *w;
      uint8_t *sbox;
    }
    case_AES128_VALE;
    struct 
    {
      uint8_t *w;
      uint8_t *sbox;
    }
    case_AES128_HACL;
  }
  ;
}
EverCrypt_aes128_key_s;

bool EverCrypt_uu___is_AES128_OPENSSL(EverCrypt_aes128_key_s projectee)
{
  if (projectee.tag == EverCrypt_AES128_OPENSSL)
  {
    return true;
  }
  else
  {
    return false;
  }
}

FStar_Dyn_dyn EverCrypt___proj__AES128_OPENSSL__item__st(EverCrypt_aes128_key_s projectee)
{
  if (projectee.tag == EverCrypt_AES128_OPENSSL)
  {
    return projectee.case_AES128_OPENSSL;
  }
  else
  {
    KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool EverCrypt_uu___is_AES128_BCRYPT(EverCrypt_aes128_key_s projectee)
{
  if (projectee.tag == EverCrypt_AES128_BCRYPT)
  {
    return true;
  }
  else
  {
    return false;
  }
}

FStar_Dyn_dyn EverCrypt___proj__AES128_BCRYPT__item__st(EverCrypt_aes128_key_s projectee)
{
  if (projectee.tag == EverCrypt_AES128_BCRYPT)
  {
    return projectee.case_AES128_BCRYPT;
  }
  else
  {
    KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool EverCrypt_uu___is_AES128_VALE(EverCrypt_aes128_key_s projectee)
{
  if (projectee.tag == EverCrypt_AES128_VALE)
  {
    return true;
  }
  else
  {
    return false;
  }
}

uint8_t *EverCrypt___proj__AES128_VALE__item__w(EverCrypt_aes128_key_s projectee)
{
  if (projectee.tag == EverCrypt_AES128_VALE)
  {
    return projectee.case_AES128_VALE.w;
  }
  else
  {
    KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

uint8_t *EverCrypt___proj__AES128_VALE__item__sbox(EverCrypt_aes128_key_s projectee)
{
  if (projectee.tag == EverCrypt_AES128_VALE)
  {
    return projectee.case_AES128_VALE.sbox;
  }
  else
  {
    KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool EverCrypt_uu___is_AES128_HACL(EverCrypt_aes128_key_s projectee)
{
  if (projectee.tag == EverCrypt_AES128_HACL)
  {
    return true;
  }
  else
  {
    return false;
  }
}

uint8_t *EverCrypt___proj__AES128_HACL__item__w(EverCrypt_aes128_key_s projectee)
{
  if (projectee.tag == EverCrypt_AES128_HACL)
  {
    return projectee.case_AES128_HACL.w;
  }
  else
  {
    KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

uint8_t *EverCrypt___proj__AES128_HACL__item__sbox(EverCrypt_aes128_key_s projectee)
{
  if (projectee.tag == EverCrypt_AES128_HACL)
  {
    return projectee.case_AES128_HACL.sbox;
  }
  else
  {
    KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static EverCrypt_aes128_key_s C_Failure_failwith__EverCrypt_aes128_key_s(C_String_t s)
{
  C_String_print(s);
  if (C_Failure_whatever())
  {
    portable_exit((int32_t)255);
  }
  return C_Failure_failwith__EverCrypt_aes128_key_s(s);
}

EverCrypt_aes128_key_s *EverCrypt_aes128_create(uint8_t *k1)
{
  bool ite0;
  if (EverCrypt_AutoConfig2_wants_vale())
  {
    ite0 = EverCrypt_AutoConfig2_has_aesni();
  }
  else
  {
    ite0 = false;
  }
  EverCrypt_aes128_key_s st;
  if (ite0)
  {
    uint8_t *w1 = KRML_HOST_CALLOC((uint32_t)176U, sizeof (uint8_t));
    uint8_t *sbox = KRML_HOST_CALLOC((uint32_t)256U, sizeof (uint8_t));
    aes128_key_expansion_sbox(k1, w1, sbox);
    st =
      (
        (EverCrypt_aes128_key_s){
          .tag = EverCrypt_AES128_VALE,
          { .case_AES128_VALE = { .w = w1, .sbox = sbox } }
        }
      );
  }
  else
  {
    EverCrypt_aes128_key_s ite;
    if (EverCrypt_AutoConfig2_wants_hacl())
    {
      uint8_t *w1 = KRML_HOST_CALLOC((uint32_t)176U, sizeof (uint8_t));
      uint8_t *sbox = KRML_HOST_CALLOC((uint32_t)256U, sizeof (uint8_t));
      EverCrypt_Hacl_aes128_mk_sbox(sbox);
      EverCrypt_Hacl_aes128_keyExpansion(k1, w1, sbox);
      ite =
        (
          (EverCrypt_aes128_key_s){
            .tag = EverCrypt_AES128_HACL,
            { .case_AES128_HACL = { .w = w1, .sbox = sbox } }
          }
        );
    }
    else
    {
      ite =
        C_Failure_failwith__EverCrypt_aes128_key_s("ERROR: inconsistent configuration (aes128_create)");
    }
    st = ite;
  }
  KRML_CHECK_SIZE(sizeof (EverCrypt_aes128_key_s), (uint32_t)1U);
  EverCrypt_aes128_key_s *buf = KRML_HOST_MALLOC(sizeof (EverCrypt_aes128_key_s));
  buf[0U] = st;
  return buf;
}

void EverCrypt_aes128_compute(EverCrypt_aes128_key_s *k1, uint8_t *plain, uint8_t *cipher1)
{
  EverCrypt_aes128_key_s k2 = *k1;
  if (true && EverCrypt_uu___is_AES128_VALE(k2))
  {
    if (k2.tag == EverCrypt_AES128_VALE)
    {
      uint8_t *sbox = k2.case_AES128_VALE.sbox;
      uint8_t *w1 = k2.case_AES128_VALE.w;
      aes128_encrypt_one_block(cipher1, plain, w1, sbox);
    }
    else
    {
      KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else
  {
    if (true && EverCrypt_uu___is_AES128_HACL(k2))
    {
      if (k2.tag == EverCrypt_AES128_HACL)
      {
        uint8_t *sbox = k2.case_AES128_HACL.sbox;
        uint8_t *w1 = k2.case_AES128_HACL.w;
        EverCrypt_Hacl_aes128_cipher(cipher1, plain, w1, sbox);
      }
      else
      {
        KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else
    {
      C_Failure_failwith____("ERROR: inconsistent configuration (aes128_compute)");
    }
  }
}

void EverCrypt_aes128_free(EverCrypt_aes128_key_s *pk)
{
  EverCrypt_aes128_key_s k1 = *pk;
  if (true && EverCrypt_uu___is_AES128_VALE(k1))
  {
    if (k1.tag == EverCrypt_AES128_VALE)
    {
      uint8_t *sbox = k1.case_AES128_VALE.sbox;
      uint8_t *w1 = k1.case_AES128_VALE.w;
      KRML_HOST_FREE(w1);
      KRML_HOST_FREE(sbox);
    }
    else
    {
      KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else
  {
    if (true && EverCrypt_uu___is_AES128_HACL(k1))
    {
      if (k1.tag == EverCrypt_AES128_HACL)
      {
        uint8_t *sbox = k1.case_AES128_HACL.sbox;
        uint8_t *w1 = k1.case_AES128_HACL.w;
        KRML_HOST_FREE(w1);
        KRML_HOST_FREE(sbox);
      }
      else
      {
        KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else
    {
      C_Failure_failwith____("ERROR: inconsistent configuration (aes128_free)");
    }
  }
  KRML_HOST_FREE(pk);
}

typedef struct EverCrypt_aes256_key_s_s
{
  EverCrypt_aes256_key_s_tags tag;
  union {
    FStar_Dyn_dyn case_AES256_OPENSSL;
    FStar_Dyn_dyn case_AES256_BCRYPT;
    struct 
    {
      uint8_t *w;
      uint8_t *sbox;
    }
    case_AES256_HACL;
  }
  ;
}
EverCrypt_aes256_key_s;

bool EverCrypt_uu___is_AES256_OPENSSL(EverCrypt_aes256_key_s projectee)
{
  if (projectee.tag == EverCrypt_AES256_OPENSSL)
  {
    return true;
  }
  else
  {
    return false;
  }
}

FStar_Dyn_dyn EverCrypt___proj__AES256_OPENSSL__item__st(EverCrypt_aes256_key_s projectee)
{
  if (projectee.tag == EverCrypt_AES256_OPENSSL)
  {
    return projectee.case_AES256_OPENSSL;
  }
  else
  {
    KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool EverCrypt_uu___is_AES256_BCRYPT(EverCrypt_aes256_key_s projectee)
{
  if (projectee.tag == EverCrypt_AES256_BCRYPT)
  {
    return true;
  }
  else
  {
    return false;
  }
}

FStar_Dyn_dyn EverCrypt___proj__AES256_BCRYPT__item__st(EverCrypt_aes256_key_s projectee)
{
  if (projectee.tag == EverCrypt_AES256_BCRYPT)
  {
    return projectee.case_AES256_BCRYPT;
  }
  else
  {
    KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

bool EverCrypt_uu___is_AES256_HACL(EverCrypt_aes256_key_s projectee)
{
  if (projectee.tag == EverCrypt_AES256_HACL)
  {
    return true;
  }
  else
  {
    return false;
  }
}

uint8_t *EverCrypt___proj__AES256_HACL__item__w(EverCrypt_aes256_key_s projectee)
{
  if (projectee.tag == EverCrypt_AES256_HACL)
  {
    return projectee.case_AES256_HACL.w;
  }
  else
  {
    KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

uint8_t *EverCrypt___proj__AES256_HACL__item__sbox(EverCrypt_aes256_key_s projectee)
{
  if (projectee.tag == EverCrypt_AES256_HACL)
  {
    return projectee.case_AES256_HACL.sbox;
  }
  else
  {
    KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
      __FILE__,
      __LINE__,
      "unreachable (pattern matches are exhaustive in F*)");
    KRML_HOST_EXIT(255U);
  }
}

static EverCrypt_aes256_key_s C_Failure_failwith__EverCrypt_aes256_key_s(C_String_t s)
{
  C_String_print(s);
  if (C_Failure_whatever())
  {
    portable_exit((int32_t)255);
  }
  return C_Failure_failwith__EverCrypt_aes256_key_s(s);
}

EverCrypt_aes256_key_s *EverCrypt_aes256_create(uint8_t *k1)
{
  EverCrypt_aes256_key_s st;
  if (EverCrypt_AutoConfig2_wants_hacl())
  {
    uint8_t *w1 = KRML_HOST_CALLOC((uint32_t)240U, sizeof (uint8_t));
    uint8_t *sbox = KRML_HOST_CALLOC((uint32_t)256U, sizeof (uint8_t));
    EverCrypt_Hacl_aes256_mk_sbox(sbox);
    EverCrypt_Hacl_aes256_keyExpansion(k1, w1, sbox);
    st =
      (
        (EverCrypt_aes256_key_s){
          .tag = EverCrypt_AES256_HACL,
          { .case_AES256_HACL = { .w = w1, .sbox = sbox } }
        }
      );
  }
  else
  {
    st =
      C_Failure_failwith__EverCrypt_aes256_key_s("ERROR: inconsistent configuration (aes256_create)");
  }
  KRML_CHECK_SIZE(sizeof (EverCrypt_aes256_key_s), (uint32_t)1U);
  EverCrypt_aes256_key_s *buf = KRML_HOST_MALLOC(sizeof (EverCrypt_aes256_key_s));
  buf[0U] = st;
  return buf;
}

void EverCrypt_aes256_compute(EverCrypt_aes256_key_s *k1, uint8_t *plain, uint8_t *cipher1)
{
  EverCrypt_aes256_key_s k2 = *k1;
  if (true && EverCrypt_uu___is_AES256_HACL(k2))
  {
    if (k2.tag == EverCrypt_AES256_HACL)
    {
      uint8_t *sbox = k2.case_AES256_HACL.sbox;
      uint8_t *w1 = k2.case_AES256_HACL.w;
      EverCrypt_Hacl_aes256_cipher(cipher1, plain, w1, sbox);
    }
    else
    {
      KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else
  {
    C_Failure_failwith____("ERROR: inconsistent configuration (aes256_compute)");
  }
}

void EverCrypt_aes256_free(EverCrypt_aes256_key_s *pk)
{
  EverCrypt_aes256_key_s k1 = *pk;
  if (true && EverCrypt_uu___is_AES256_HACL(k1))
  {
    if (k1.tag == EverCrypt_AES256_HACL)
    {
      uint8_t *sbox = k1.case_AES256_HACL.sbox;
      uint8_t *w1 = k1.case_AES256_HACL.w;
      KRML_HOST_FREE(w1);
      KRML_HOST_FREE(sbox);
    }
    else
    {
      KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else
  {
    C_Failure_failwith____("ERROR: inconsistent configuration (aes256_free)");
  }
  KRML_HOST_FREE(pk);
}

void
EverCrypt_chacha20(
  uint8_t *key,
  uint8_t *iv,
  uint32_t ctr,
  uint8_t *plain,
  uint32_t len1,
  uint8_t *cipher1
)
{
  if (EverCrypt_AutoConfig2_wants_hacl())
  {
    EverCrypt_Hacl_chacha20(key, iv, ctr, plain, len1, cipher1);
  }
  else
  {
    C_Failure_failwith____("ERROR: inconsistent configuration (chacha20)");
  }
}

void
EverCrypt_aes128_gcm_encrypt(
  uint8_t *key,
  uint8_t *iv,
  uint8_t *ad,
  uint32_t adlen,
  uint8_t *plaintext,
  uint32_t len1,
  uint8_t *cipher1,
  uint8_t *tag
)
{
  bool ite;
  if (EverCrypt_AutoConfig2_wants_vale())
  {
    ite = EverCrypt_AutoConfig2_has_aesni();
  }
  else
  {
    ite = false;
  }
  if (ite)
  {
    uint8_t expanded[176U] = { 0U };
    aes128_key_expansion(key, expanded);
    uint8_t iv_[16U] = { 0U };
    KRML_CHECK_SIZE(sizeof (uint8_t), (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U);
    uint8_t plaintext_[(len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U];
    memset(plaintext_,
      0U,
      (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U * sizeof plaintext_[0U]);
    KRML_CHECK_SIZE(sizeof (uint8_t), (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U);
    uint8_t cipher_[(len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U];
    memset(cipher_,
      0U,
      (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U * sizeof cipher_[0U]);
    KRML_CHECK_SIZE(sizeof (uint8_t), (adlen + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U);
    uint8_t ad_[(adlen + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U];
    memset(ad_, 0U, (adlen + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U * sizeof ad_[0U]);
    memcpy(iv_, iv, (uint32_t)12U * sizeof iv[0U]);
    memcpy(plaintext_, plaintext, len1 * sizeof plaintext[0U]);
    memcpy(ad_, ad, adlen * sizeof ad[0U]);
    gcm_args
    b =
      {
        .plain = plaintext_, .plain_len = (uint64_t)len1, .aad = ad_, .aad_len = (uint64_t)adlen,
        .iv = iv_, .expanded_key = expanded, .cipher = cipher_, .tag = tag
      };
    gcm128_encrypt(&b);
    memcpy(cipher1, cipher_, len1 * sizeof cipher_[0U]);
  }
  else
  {
    C_Failure_failwith____("ERROR: inconsistent configuration (aes128_gcm_encrypt)");
  }
}

uint32_t
EverCrypt_aes128_gcm_decrypt(
  uint8_t *key,
  uint8_t *iv,
  uint8_t *ad,
  uint32_t adlen,
  uint8_t *plaintext,
  uint32_t len1,
  uint8_t *cipher1,
  uint8_t *tag
)
{
  bool ite;
  if (EverCrypt_AutoConfig2_wants_vale())
  {
    ite = EverCrypt_AutoConfig2_has_aesni();
  }
  else
  {
    ite = false;
  }
  if (ite)
  {
    uint8_t expanded[176U] = { 0U };
    aes128_key_expansion(key, expanded);
    uint8_t iv_[16U] = { 0U };
    KRML_CHECK_SIZE(sizeof (uint8_t), (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U);
    uint8_t plaintext_[(len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U];
    memset(plaintext_,
      0U,
      (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U * sizeof plaintext_[0U]);
    KRML_CHECK_SIZE(sizeof (uint8_t), (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U);
    uint8_t cipher_[(len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U];
    memset(cipher_,
      0U,
      (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U * sizeof cipher_[0U]);
    KRML_CHECK_SIZE(sizeof (uint8_t), (adlen + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U);
    uint8_t ad_[(adlen + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U];
    memset(ad_, 0U, (adlen + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U * sizeof ad_[0U]);
    memcpy(iv_, iv, (uint32_t)12U * sizeof iv[0U]);
    memcpy(cipher_, cipher1, len1 * sizeof cipher1[0U]);
    memcpy(ad_, ad, adlen * sizeof ad[0U]);
    gcm_args
    b =
      {
        .plain = cipher_, .plain_len = (uint64_t)len1, .aad = ad_, .aad_len = (uint64_t)adlen,
        .iv = iv_, .expanded_key = expanded, .cipher = plaintext_, .tag = tag
      };
    uint32_t ret = gcm128_decrypt(&b);
    memcpy(plaintext, plaintext_, len1 * sizeof plaintext_[0U]);
    uint32_t r;
    if (ret == (uint32_t)0U)
    {
      r = (uint32_t)1U;
    }
    else
    {
      r = (uint32_t)0U;
    }
    return r;
  }
  else
  {
    return C_Failure_failwith__uint32_t("ERROR: inconsistent configuration (aes128_gcm_decrypt)");
  }
}

void
EverCrypt_aes256_gcm_encrypt(
  uint8_t *key,
  uint8_t *iv,
  uint8_t *ad,
  uint32_t adlen,
  uint8_t *plaintext,
  uint32_t len1,
  uint8_t *cipher1,
  uint8_t *tag
)
{
  bool ite;
  if (EverCrypt_AutoConfig2_wants_vale())
  {
    ite = EverCrypt_AutoConfig2_has_aesni();
  }
  else
  {
    ite = false;
  }
  if (ite)
  {
    uint8_t expanded[240U] = { 0U };
    aes256_key_expansion(key, expanded);
    uint8_t iv_[16U] = { 0U };
    KRML_CHECK_SIZE(sizeof (uint8_t), (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U);
    uint8_t plaintext_[(len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U];
    memset(plaintext_,
      0U,
      (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U * sizeof plaintext_[0U]);
    KRML_CHECK_SIZE(sizeof (uint8_t), (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U);
    uint8_t cipher_[(len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U];
    memset(cipher_,
      0U,
      (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U * sizeof cipher_[0U]);
    KRML_CHECK_SIZE(sizeof (uint8_t), (adlen + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U);
    uint8_t ad_[(adlen + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U];
    memset(ad_, 0U, (adlen + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U * sizeof ad_[0U]);
    memcpy(iv_, iv, (uint32_t)12U * sizeof iv[0U]);
    memcpy(plaintext_, plaintext, len1 * sizeof plaintext[0U]);
    memcpy(ad_, ad, adlen * sizeof ad[0U]);
    gcm_args
    b =
      {
        .plain = plaintext_, .plain_len = (uint64_t)len1, .aad = ad_, .aad_len = (uint64_t)adlen,
        .iv = iv_, .expanded_key = expanded, .cipher = cipher_, .tag = tag
      };
    gcm256_encrypt(&b);
    memcpy(cipher1, cipher_, len1 * sizeof cipher_[0U]);
  }
  else
  {
    C_Failure_failwith____("ERROR: inconsistent configuration (aes256_gcm_encrypt)");
  }
}

uint32_t
EverCrypt_aes256_gcm_decrypt(
  uint8_t *key,
  uint8_t *iv,
  uint8_t *ad,
  uint32_t adlen,
  uint8_t *plaintext,
  uint32_t len1,
  uint8_t *cipher1,
  uint8_t *tag
)
{
  bool ite;
  if (EverCrypt_AutoConfig2_wants_vale())
  {
    ite = EverCrypt_AutoConfig2_has_aesni();
  }
  else
  {
    ite = false;
  }
  if (ite)
  {
    uint8_t expanded[240U] = { 0U };
    aes256_key_expansion(key, expanded);
    uint8_t iv_[16U] = { 0U };
    KRML_CHECK_SIZE(sizeof (uint8_t), (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U);
    uint8_t plaintext_[(len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U];
    memset(plaintext_,
      0U,
      (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U * sizeof plaintext_[0U]);
    KRML_CHECK_SIZE(sizeof (uint8_t), (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U);
    uint8_t cipher_[(len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U];
    memset(cipher_,
      0U,
      (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U * sizeof cipher_[0U]);
    KRML_CHECK_SIZE(sizeof (uint8_t), (adlen + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U);
    uint8_t ad_[(adlen + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U];
    memset(ad_, 0U, (adlen + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U * sizeof ad_[0U]);
    memcpy(iv_, iv, (uint32_t)12U * sizeof iv[0U]);
    memcpy(cipher_, cipher1, len1 * sizeof cipher1[0U]);
    memcpy(ad_, ad, adlen * sizeof ad[0U]);
    gcm_args
    b =
      {
        .plain = cipher_, .plain_len = (uint64_t)len1, .aad = ad_, .aad_len = (uint64_t)adlen,
        .iv = iv_, .expanded_key = expanded, .cipher = plaintext_, .tag = tag
      };
    uint32_t ret = gcm256_decrypt(&b);
    memcpy(plaintext, plaintext_, len1 * sizeof plaintext_[0U]);
    uint32_t r;
    if (ret == (uint32_t)0U)
    {
      r = (uint32_t)1U;
    }
    else
    {
      r = (uint32_t)0U;
    }
    return r;
  }
  else
  {
    return C_Failure_failwith__uint32_t("ERROR: inconsistent configuration (aes256_gcm_decrypt)");
  }
}

void
EverCrypt_chacha20_poly1305_encrypt(
  uint8_t *key,
  uint8_t *iv,
  uint8_t *ad,
  uint32_t adlen,
  uint8_t *plaintext,
  uint32_t len1,
  uint8_t *cipher1,
  uint8_t *tag
)
{
  if (EverCrypt_AutoConfig2_wants_hacl())
  {
    uint32_t
    uu____0 =
      EverCrypt_Hacl_chacha20_poly1305_encrypt(cipher1,
        tag,
        plaintext,
        len1,
        ad,
        adlen,
        key,
        iv);
  }
  else
  {
    C_Failure_failwith____("ERROR: inconsistent configuration (chacha20_poly1305_encrypt)");
  }
}

uint32_t
EverCrypt_chacha20_poly1305_decrypt(
  uint8_t *key,
  uint8_t *iv,
  uint8_t *ad,
  uint32_t adlen,
  uint8_t *plaintext,
  uint32_t len1,
  uint8_t *cipher1,
  uint8_t *tag
)
{
  if (EverCrypt_AutoConfig2_wants_hacl())
  {
    return
      (uint32_t)1U
      - EverCrypt_Hacl_chacha20_poly1305_decrypt(plaintext, cipher1, len1, tag, ad, adlen, key, iv);
  }
  else
  {
    return
      C_Failure_failwith__uint32_t("ERROR: inconsistent configuration (chacha20_poly1305_decrypt)");
  }
}

bool EverCrypt_uu___is_AES128_CBC(EverCrypt_block_cipher_alg projectee)
{
  switch (projectee)
  {
    case EverCrypt_AES128_CBC:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool EverCrypt_uu___is_AES256_CBC(EverCrypt_block_cipher_alg projectee)
{
  switch (projectee)
  {
    case EverCrypt_AES256_CBC:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool EverCrypt_uu___is_TDES_EDE_CBC(EverCrypt_block_cipher_alg projectee)
{
  switch (projectee)
  {
    case EverCrypt_TDES_EDE_CBC:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

uint32_t EverCrypt_block_cipher_keyLen(EverCrypt_block_cipher_alg uu___173_12401)
{
  switch (uu___173_12401)
  {
    case EverCrypt_AES128_CBC:
      {
        return (uint32_t)16U;
      }
    case EverCrypt_AES256_CBC:
      {
        return (uint32_t)32U;
      }
    case EverCrypt_TDES_EDE_CBC:
      {
        return (uint32_t)24U;
      }
    default:
      {
        KRML_HOST_PRINTF("KreMLin incomplete match at %s:%d\n", __FILE__, __LINE__);
        KRML_HOST_EXIT(253U);
      }
  }
}

uint32_t EverCrypt_block_cipher_blockLen(EverCrypt_block_cipher_alg uu___174_12411)
{
  switch (uu___174_12411)
  {
    case EverCrypt_AES128_CBC:
      {
        return (uint32_t)16U;
      }
    case EverCrypt_AES256_CBC:
      {
        return (uint32_t)16U;
      }
    case EverCrypt_TDES_EDE_CBC:
      {
        return (uint32_t)8U;
      }
    default:
      {
        KRML_HOST_PRINTF("KreMLin incomplete match at %s:%d\n", __FILE__, __LINE__);
        KRML_HOST_EXIT(253U);
      }
  }
}

bool EverCrypt_uu___is_RC4_128(EverCrypt_stream_cipher_alg projectee)
{
  return true;
}

bool EverCrypt_uu___is_AES128_GCM(EverCrypt_aead_alg projectee)
{
  switch (projectee)
  {
    case EverCrypt_AES128_GCM:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool EverCrypt_uu___is_AES256_GCM(EverCrypt_aead_alg projectee)
{
  switch (projectee)
  {
    case EverCrypt_AES256_GCM:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool EverCrypt_uu___is_CHACHA20_POLY1305(EverCrypt_aead_alg projectee)
{
  switch (projectee)
  {
    case EverCrypt_CHACHA20_POLY1305:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool EverCrypt_uu___is_AES128_CCM(EverCrypt_aead_alg projectee)
{
  switch (projectee)
  {
    case EverCrypt_AES128_CCM:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool EverCrypt_uu___is_AES256_CCM(EverCrypt_aead_alg projectee)
{
  switch (projectee)
  {
    case EverCrypt_AES256_CCM:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool EverCrypt_uu___is_AES128_CCM8(EverCrypt_aead_alg projectee)
{
  switch (projectee)
  {
    case EverCrypt_AES128_CCM8:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool EverCrypt_uu___is_AES256_CCM8(EverCrypt_aead_alg projectee)
{
  switch (projectee)
  {
    case EverCrypt_AES256_CCM8:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

uint32_t EverCrypt_aead_keyLen(EverCrypt_aead_alg uu___175_12518)
{
  switch (uu___175_12518)
  {
    case EverCrypt_AES128_GCM:
      {
        return (uint32_t)16U;
      }
    case EverCrypt_AES256_GCM:
      {
        return (uint32_t)32U;
      }
    case EverCrypt_CHACHA20_POLY1305:
      {
        return (uint32_t)32U;
      }
    case EverCrypt_AES128_CCM:
      {
        return (uint32_t)16U;
      }
    case EverCrypt_AES128_CCM8:
      {
        return (uint32_t)16U;
      }
    case EverCrypt_AES256_CCM:
      {
        return (uint32_t)32U;
      }
    case EverCrypt_AES256_CCM8:
      {
        return (uint32_t)32U;
      }
    default:
      {
        KRML_HOST_PRINTF("KreMLin incomplete match at %s:%d\n", __FILE__, __LINE__);
        KRML_HOST_EXIT(253U);
      }
  }
}

uint32_t EverCrypt_aead_tagLen(EverCrypt_aead_alg uu___176_12532)
{
  switch (uu___176_12532)
  {
    case EverCrypt_AES128_CCM8:
      {
        return (uint32_t)8U;
      }
    case EverCrypt_AES256_CCM8:
      {
        return (uint32_t)8U;
      }
    case EverCrypt_AES128_GCM:
      {
        return (uint32_t)16U;
      }
    case EverCrypt_AES256_GCM:
      {
        return (uint32_t)16U;
      }
    case EverCrypt_CHACHA20_POLY1305:
      {
        return (uint32_t)16U;
      }
    case EverCrypt_AES128_CCM:
      {
        return (uint32_t)16U;
      }
    case EverCrypt_AES256_CCM:
      {
        return (uint32_t)16U;
      }
    default:
      {
        KRML_HOST_PRINTF("KreMLin incomplete match at %s:%d\n", __FILE__, __LINE__);
        KRML_HOST_EXIT(253U);
      }
  }
}

uint32_t EverCrypt_aead_ivLen(EverCrypt_aead_alg a)
{
  return (uint32_t)12U;
}

typedef struct EverCrypt__aead_state_s
{
  EverCrypt__aead_state_tags tag;
  union {
    FStar_Dyn_dyn case_AEAD_OPENSSL;
    FStar_Dyn_dyn case_AEAD_BCRYPT;
    uint8_t *case_AEAD_AES128_GCM_VALE;
    uint8_t *case_AEAD_AES256_GCM_VALE;
    uint8_t *case_AEAD_CHACHA20_POLY1305_HACL;
  }
  ;
}
EverCrypt__aead_state;

static bool EverCrypt_uu___is_AEAD_AES128_GCM_VALE(EverCrypt__aead_state projectee)
{
  if (projectee.tag == EverCrypt_AEAD_AES128_GCM_VALE)
  {
    return true;
  }
  else
  {
    return false;
  }
}

static bool EverCrypt_uu___is_AEAD_AES256_GCM_VALE(EverCrypt__aead_state projectee)
{
  if (projectee.tag == EverCrypt_AEAD_AES256_GCM_VALE)
  {
    return true;
  }
  else
  {
    return false;
  }
}

static bool EverCrypt_uu___is_AEAD_CHACHA20_POLY1305_HACL(EverCrypt__aead_state projectee)
{
  if (projectee.tag == EverCrypt_AEAD_CHACHA20_POLY1305_HACL)
  {
    return true;
  }
  else
  {
    return false;
  }
}

static EverCrypt__aead_state C_Failure_failwith__EverCrypt__aead_state(C_String_t s)
{
  C_String_print(s);
  if (C_Failure_whatever())
  {
    portable_exit((int32_t)255);
  }
  return C_Failure_failwith__EverCrypt__aead_state(s);
}

EverCrypt__aead_state *EverCrypt_aead_create(EverCrypt_aead_alg alg, uint8_t *k1)
{
  EverCrypt__aead_state st;
  switch (alg)
  {
    case EverCrypt_AES128_GCM:
      {
        bool ite0;
        if (EverCrypt_AutoConfig2_wants_vale())
        {
          ite0 = EverCrypt_AutoConfig2_has_aesni();
        }
        else
        {
          ite0 = false;
        }
        EverCrypt__aead_state ite;
        if (ite0)
        {
          uint8_t *xk = KRML_HOST_CALLOC((uint32_t)176U, sizeof (uint8_t));
          aes128_key_expansion(k1, xk);
          ite =
            (
              (EverCrypt__aead_state){
                .tag = EverCrypt_AEAD_AES128_GCM_VALE,
                { .case_AEAD_AES128_GCM_VALE = xk }
              }
            );
        }
        else
        {
          ite =
            C_Failure_failwith__EverCrypt__aead_state("ERROR: inconsistent configuration (aead_create/AES128_GCM)");
        }
        st = ite;
        break;
      }
    case EverCrypt_AES256_GCM:
      {
        bool ite0;
        if (EverCrypt_AutoConfig2_wants_vale())
        {
          ite0 = EverCrypt_AutoConfig2_has_aesni();
        }
        else
        {
          ite0 = false;
        }
        EverCrypt__aead_state ite;
        if (ite0)
        {
          uint8_t *xk = KRML_HOST_CALLOC((uint32_t)240U, sizeof (uint8_t));
          aes256_key_expansion(k1, xk);
          ite =
            (
              (EverCrypt__aead_state){
                .tag = EverCrypt_AEAD_AES256_GCM_VALE,
                { .case_AEAD_AES256_GCM_VALE = xk }
              }
            );
        }
        else
        {
          ite =
            C_Failure_failwith__EverCrypt__aead_state("ERROR: inconsistent configuration (aead_create/AES256_GCM)");
        }
        st = ite;
        break;
      }
    case EverCrypt_CHACHA20_POLY1305:
      {
        EverCrypt__aead_state ite;
        if (EverCrypt_AutoConfig2_wants_hacl())
        {
          uint8_t *k01 = KRML_HOST_CALLOC((uint32_t)32U, sizeof (uint8_t));
          memcpy(k01, k1, (uint32_t)32U * sizeof k1[0U]);
          ite =
            (
              (EverCrypt__aead_state){
                .tag = EverCrypt_AEAD_CHACHA20_POLY1305_HACL,
                { .case_AEAD_CHACHA20_POLY1305_HACL = k01 }
              }
            );
        }
        else
        {
          ite =
            C_Failure_failwith__EverCrypt__aead_state("ERROR: inconsistent configuration (aead_create/CHACHA20_POLY1305)");
        }
        st = ite;
        break;
      }
    default:
      {
        KRML_HOST_PRINTF("KreMLin incomplete match at %s:%d\n", __FILE__, __LINE__);
        KRML_HOST_EXIT(253U);
      }
  }
  KRML_CHECK_SIZE(sizeof (EverCrypt__aead_state), (uint32_t)1U);
  EverCrypt__aead_state *buf = KRML_HOST_MALLOC(sizeof (EverCrypt__aead_state));
  buf[0U] = st;
  return buf;
}

void
EverCrypt_aead_encrypt(
  EverCrypt__aead_state *pkey,
  uint8_t *iv,
  uint8_t *ad,
  uint32_t adlen,
  uint8_t *plaintext,
  uint32_t len1,
  uint8_t *cipher1,
  uint8_t *tag
)
{
  EverCrypt__aead_state k1 = *pkey;
  if (true && EverCrypt_uu___is_AEAD_AES128_GCM_VALE(k1))
  {
    uint8_t *xk;
    if (k1.tag == EverCrypt_AEAD_AES128_GCM_VALE)
    {
      xk = k1.case_AEAD_AES128_GCM_VALE;
    }
    else
    {
      xk = KRML_EABORT(uint8_t *, "unreachable (pattern matches are exhaustive in F*)");
    }
    uint8_t iv_[16U] = { 0U };
    KRML_CHECK_SIZE(sizeof (uint8_t), (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U);
    uint8_t plaintext_[(len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U];
    memset(plaintext_,
      0U,
      (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U * sizeof plaintext_[0U]);
    KRML_CHECK_SIZE(sizeof (uint8_t), (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U);
    uint8_t cipher_[(len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U];
    memset(cipher_,
      0U,
      (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U * sizeof cipher_[0U]);
    KRML_CHECK_SIZE(sizeof (uint8_t), (adlen + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U);
    uint8_t ad_[(adlen + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U];
    memset(ad_, 0U, (adlen + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U * sizeof ad_[0U]);
    memcpy(iv_, iv, (uint32_t)12U * sizeof iv[0U]);
    memcpy(plaintext_, plaintext, len1 * sizeof plaintext[0U]);
    memcpy(ad_, ad, adlen * sizeof ad[0U]);
    gcm_args
    b =
      {
        .plain = plaintext_, .plain_len = (uint64_t)len1, .aad = ad_, .aad_len = (uint64_t)adlen,
        .iv = iv_, .expanded_key = xk, .cipher = cipher_, .tag = tag
      };
    gcm128_encrypt(&b);
    memcpy(cipher1, cipher_, len1 * sizeof cipher_[0U]);
  }
  else
  {
    if (true && EverCrypt_uu___is_AEAD_AES256_GCM_VALE(k1))
    {
      uint8_t *xk;
      if (k1.tag == EverCrypt_AEAD_AES256_GCM_VALE)
      {
        xk = k1.case_AEAD_AES256_GCM_VALE;
      }
      else
      {
        xk = KRML_EABORT(uint8_t *, "unreachable (pattern matches are exhaustive in F*)");
      }
      uint8_t iv_[16U] = { 0U };
      KRML_CHECK_SIZE(sizeof (uint8_t), (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U);
      uint8_t plaintext_[(len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U];
      memset(plaintext_,
        0U,
        (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U * sizeof plaintext_[0U]);
      KRML_CHECK_SIZE(sizeof (uint8_t), (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U);
      uint8_t cipher_[(len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U];
      memset(cipher_,
        0U,
        (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U * sizeof cipher_[0U]);
      KRML_CHECK_SIZE(sizeof (uint8_t), (adlen + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U);
      uint8_t ad_[(adlen + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U];
      memset(ad_, 0U, (adlen + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U * sizeof ad_[0U]);
      memcpy(iv_, iv, (uint32_t)12U * sizeof iv[0U]);
      memcpy(plaintext_, plaintext, len1 * sizeof plaintext[0U]);
      memcpy(ad_, ad, adlen * sizeof ad[0U]);
      gcm_args
      b =
        {
          .plain = plaintext_, .plain_len = (uint64_t)len1, .aad = ad_, .aad_len = (uint64_t)adlen,
          .iv = iv_, .expanded_key = xk, .cipher = cipher_, .tag = tag
        };
      gcm256_encrypt(&b);
      memcpy(cipher1, cipher_, len1 * sizeof cipher_[0U]);
    }
    else
    {
      if (true && EverCrypt_uu___is_AEAD_CHACHA20_POLY1305_HACL(k1))
      {
        uint8_t *key;
        if (k1.tag == EverCrypt_AEAD_CHACHA20_POLY1305_HACL)
        {
          key = k1.case_AEAD_CHACHA20_POLY1305_HACL;
        }
        else
        {
          key = KRML_EABORT(uint8_t *, "unreachable (pattern matches are exhaustive in F*)");
        }
        uint32_t
        uu____0 =
          EverCrypt_Hacl_chacha20_poly1305_encrypt(cipher1,
            tag,
            plaintext,
            len1,
            ad,
            adlen,
            key,
            iv);
      }
      else
      {
        C_Failure_failwith____("ERROR: inconsistent configuration (aead_encrypt)");
      }
    }
  }
}

uint32_t
EverCrypt_aead_decrypt(
  EverCrypt__aead_state *pkey,
  uint8_t *iv,
  uint8_t *ad,
  uint32_t adlen,
  uint8_t *plaintext,
  uint32_t len1,
  uint8_t *cipher1,
  uint8_t *tag
)
{
  EverCrypt__aead_state k1 = *pkey;
  if (true && EverCrypt_uu___is_AEAD_AES128_GCM_VALE(k1))
  {
    uint8_t *xk;
    if (k1.tag == EverCrypt_AEAD_AES128_GCM_VALE)
    {
      xk = k1.case_AEAD_AES128_GCM_VALE;
    }
    else
    {
      xk = KRML_EABORT(uint8_t *, "unreachable (pattern matches are exhaustive in F*)");
    }
    uint8_t iv_[16U] = { 0U };
    KRML_CHECK_SIZE(sizeof (uint8_t), (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U);
    uint8_t plaintext_[(len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U];
    memset(plaintext_,
      0U,
      (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U * sizeof plaintext_[0U]);
    KRML_CHECK_SIZE(sizeof (uint8_t), (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U);
    uint8_t cipher_[(len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U];
    memset(cipher_,
      0U,
      (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U * sizeof cipher_[0U]);
    KRML_CHECK_SIZE(sizeof (uint8_t), (adlen + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U);
    uint8_t ad_[(adlen + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U];
    memset(ad_, 0U, (adlen + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U * sizeof ad_[0U]);
    memcpy(iv_, iv, (uint32_t)12U * sizeof iv[0U]);
    memcpy(cipher_, cipher1, len1 * sizeof cipher1[0U]);
    memcpy(ad_, ad, adlen * sizeof ad[0U]);
    gcm_args
    b =
      {
        .plain = cipher_, .plain_len = (uint64_t)len1, .aad = ad_, .aad_len = (uint64_t)adlen,
        .iv = iv_, .expanded_key = xk, .cipher = plaintext_, .tag = tag
      };
    uint32_t ret = gcm128_decrypt(&b);
    memcpy(plaintext, plaintext_, len1 * sizeof plaintext_[0U]);
    if (ret == (uint32_t)0U)
    {
      return (uint32_t)1U;
    }
    else
    {
      return (uint32_t)0U;
    }
  }
  else
  {
    if (true && EverCrypt_uu___is_AEAD_AES256_GCM_VALE(k1))
    {
      uint8_t *xk;
      if (k1.tag == EverCrypt_AEAD_AES256_GCM_VALE)
      {
        xk = k1.case_AEAD_AES256_GCM_VALE;
      }
      else
      {
        xk = KRML_EABORT(uint8_t *, "unreachable (pattern matches are exhaustive in F*)");
      }
      uint8_t iv_[16U] = { 0U };
      KRML_CHECK_SIZE(sizeof (uint8_t), (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U);
      uint8_t plaintext_[(len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U];
      memset(plaintext_,
        0U,
        (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U * sizeof plaintext_[0U]);
      KRML_CHECK_SIZE(sizeof (uint8_t), (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U);
      uint8_t cipher_[(len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U];
      memset(cipher_,
        0U,
        (len1 + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U * sizeof cipher_[0U]);
      KRML_CHECK_SIZE(sizeof (uint8_t), (adlen + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U);
      uint8_t ad_[(adlen + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U];
      memset(ad_, 0U, (adlen + (uint32_t)15U) / (uint32_t)16U * (uint32_t)16U * sizeof ad_[0U]);
      memcpy(iv_, iv, (uint32_t)12U * sizeof iv[0U]);
      memcpy(cipher_, cipher1, len1 * sizeof cipher1[0U]);
      memcpy(ad_, ad, adlen * sizeof ad[0U]);
      gcm_args
      b =
        {
          .plain = cipher_, .plain_len = (uint64_t)len1, .aad = ad_, .aad_len = (uint64_t)adlen,
          .iv = iv_, .expanded_key = xk, .cipher = plaintext_, .tag = tag
        };
      uint32_t ret = gcm256_decrypt(&b);
      memcpy(plaintext, plaintext_, len1 * sizeof plaintext_[0U]);
      if (ret == (uint32_t)0U)
      {
        return (uint32_t)1U;
      }
      else
      {
        return (uint32_t)0U;
      }
    }
    else
    {
      if (true && EverCrypt_uu___is_AEAD_CHACHA20_POLY1305_HACL(k1))
      {
        uint8_t *key;
        if (k1.tag == EverCrypt_AEAD_CHACHA20_POLY1305_HACL)
        {
          key = k1.case_AEAD_CHACHA20_POLY1305_HACL;
        }
        else
        {
          key = KRML_EABORT(uint8_t *, "unreachable (pattern matches are exhaustive in F*)");
        }
        uint32_t
        r =
          EverCrypt_Hacl_chacha20_poly1305_decrypt(plaintext,
            cipher1,
            len1,
            tag,
            ad,
            adlen,
            key,
            iv);
        return (uint32_t)1U - r;
      }
      else
      {
        return C_Failure_failwith__uint32_t("ERROR: inconsistent configuration (aead_decrypt)");
      }
    }
  }
}

void EverCrypt_aead_free(EverCrypt__aead_state *pk)
{
  EverCrypt__aead_state k1 = *pk;
  if (true && EverCrypt_uu___is_AEAD_AES128_GCM_VALE(k1))
  {
    if (k1.tag == EverCrypt_AEAD_AES128_GCM_VALE)
    {
      uint8_t *xk = k1.case_AEAD_AES128_GCM_VALE;
      KRML_HOST_FREE(xk);
    }
    else
    {
      KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
        __FILE__,
        __LINE__,
        "unreachable (pattern matches are exhaustive in F*)");
      KRML_HOST_EXIT(255U);
    }
  }
  else
  {
    if (true && EverCrypt_uu___is_AEAD_AES256_GCM_VALE(k1))
    {
      if (k1.tag == EverCrypt_AEAD_AES256_GCM_VALE)
      {
        uint8_t *xk = k1.case_AEAD_AES256_GCM_VALE;
        KRML_HOST_FREE(xk);
      }
      else
      {
        KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
          __FILE__,
          __LINE__,
          "unreachable (pattern matches are exhaustive in F*)");
        KRML_HOST_EXIT(255U);
      }
    }
    else
    {
      if (true && EverCrypt_uu___is_AEAD_CHACHA20_POLY1305_HACL(k1))
      {
        if (k1.tag == EverCrypt_AEAD_CHACHA20_POLY1305_HACL)
        {
          uint8_t *key = k1.case_AEAD_CHACHA20_POLY1305_HACL;
          KRML_HOST_FREE(key);
        }
        else
        {
          KRML_HOST_PRINTF("KreMLin abort at %s:%d\n%s\n",
            __FILE__,
            __LINE__,
            "unreachable (pattern matches are exhaustive in F*)");
          KRML_HOST_EXIT(255U);
        }
      }
      else
      {
        C_Failure_failwith____("ERROR: inconsistent configuration (aead_free)");
      }
    }
  }
  KRML_HOST_FREE(pk);
}

typedef struct EverCrypt__dh_state_s
{
  EverCrypt__dh_state_tags tag;
  FStar_Dyn_dyn st;
}
EverCrypt__dh_state;

static EverCrypt__dh_state C_Failure_failwith__EverCrypt__dh_state(C_String_t s)
{
  C_String_print(s);
  if (C_Failure_whatever())
  {
    portable_exit((int32_t)255);
  }
  return C_Failure_failwith__EverCrypt__dh_state(s);
}

EverCrypt__dh_state
*EverCrypt_dh_load_group(
  uint8_t *dh_p,
  uint32_t dh_p_len,
  uint8_t *dh_g,
  uint32_t dh_g_len,
  uint8_t *dh_q,
  uint32_t dh_q_len
)
{
  EverCrypt__dh_state
  st =
    C_Failure_failwith__EverCrypt__dh_state("ERROR: inconsistent configuration (dh_load_group)");
  KRML_CHECK_SIZE(sizeof (EverCrypt__dh_state), (uint32_t)1U);
  EverCrypt__dh_state *buf = KRML_HOST_MALLOC(sizeof (EverCrypt__dh_state));
  buf[0U] = st;
  return buf;
}

void EverCrypt_dh_free_group(EverCrypt__dh_state *st)
{
  EverCrypt__dh_state s = *st;
  C_Failure_failwith____("ERROR: inconsistent configuration (dh_free_group)");
  KRML_HOST_FREE(st);
}

uint32_t EverCrypt_dh_keygen(EverCrypt__dh_state *st, uint8_t *public)
{
  EverCrypt__dh_state s = *st;
  return C_Failure_failwith__uint32_t("ERROR: inconsistent configuration (dh_keygen)");
}

uint32_t
EverCrypt_dh_compute(
  EverCrypt__dh_state *st,
  uint8_t *public,
  uint32_t public_len,
  uint8_t *out
)
{
  EverCrypt__dh_state s = *st;
  return C_Failure_failwith__uint32_t("ERROR: inconsistent configuration (dh_compute)");
}

bool EverCrypt_uu___is_ECC_P256(EverCrypt_ec_curve projectee)
{
  switch (projectee)
  {
    case EverCrypt_ECC_P256:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool EverCrypt_uu___is_ECC_P384(EverCrypt_ec_curve projectee)
{
  switch (projectee)
  {
    case EverCrypt_ECC_P384:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool EverCrypt_uu___is_ECC_P521(EverCrypt_ec_curve projectee)
{
  switch (projectee)
  {
    case EverCrypt_ECC_P521:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool EverCrypt_uu___is_ECC_X25519(EverCrypt_ec_curve projectee)
{
  switch (projectee)
  {
    case EverCrypt_ECC_X25519:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

bool EverCrypt_uu___is_ECC_X448(EverCrypt_ec_curve projectee)
{
  switch (projectee)
  {
    case EverCrypt_ECC_X448:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

typedef struct EverCrypt__ecdh_state_s
{
  EverCrypt__ecdh_state_tags tag;
  FStar_Dyn_dyn st;
}
EverCrypt__ecdh_state;

static EverCrypt__ecdh_state C_Failure_failwith__EverCrypt__ecdh_state(C_String_t s)
{
  C_String_print(s);
  if (C_Failure_whatever())
  {
    portable_exit((int32_t)255);
  }
  return C_Failure_failwith__EverCrypt__ecdh_state(s);
}

EverCrypt__ecdh_state *EverCrypt_ecdh_load_curve(EverCrypt_ec_curve g1)
{
  EverCrypt__ecdh_state
  st =
    C_Failure_failwith__EverCrypt__ecdh_state("ERROR: inconsistent configuration (ecdh_load_curve)");
  KRML_CHECK_SIZE(sizeof (EverCrypt__ecdh_state), (uint32_t)1U);
  EverCrypt__ecdh_state *buf = KRML_HOST_MALLOC(sizeof (EverCrypt__ecdh_state));
  buf[0U] = st;
  return buf;
}

void EverCrypt_ecdh_free_curve(EverCrypt__ecdh_state *st)
{
  EverCrypt__ecdh_state s = *st;
  C_Failure_failwith____("ERROR: inconsistent configuration (ecdh_free_curve)");
  KRML_HOST_FREE(st);
}

void EverCrypt_ecdh_keygen(EverCrypt__ecdh_state *st, uint8_t *outx, uint8_t *outy)
{
  EverCrypt__ecdh_state s = *st;
  C_Failure_failwith____("ERROR: inconsistent configuration (ecdh_keygen)");
}

uint32_t
EverCrypt_ecdh_compute(EverCrypt__ecdh_state *st, uint8_t *inx, uint8_t *iny, uint8_t *out)
{
  EverCrypt__ecdh_state s = *st;
  return C_Failure_failwith__uint32_t("ERROR: inconsistent configuration (ecdh_compute)");
}

