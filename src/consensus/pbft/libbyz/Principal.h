// Copyright (c) Microsoft Corporation.
// Copyright (c) 1999 Miguel Castro, Barbara Liskov.
// Copyright (c) 2000, 2001 Miguel Castro, Rodrigo Rodrigues, Barbara Liskov.
// Licensed under the MIT license.

#pragma once

#include "Time.h"
#include "keypair.h"
#include "network.h"
#include "types.h"

#include <string.h>
#include <sys/time.h>

extern "C"
{
#include "aes_gcm.h"
}

class Reply;

// Sizes in bytes.
const int UMAC_size = 16;
const int UNonce_size = sizeof(long long);
const int MAC_size = UMAC_size + UNonce_size;

const int Nonce_size = 16;
const int Nonce_size_u = Nonce_size / sizeof(unsigned);
const int Key_size = 16;
const int Key_size_u = Key_size / sizeof(unsigned);

const int Tag_size = 16;
const int Sig_size = 64;
const int Asym_key_size = 32;

class Principal : public IPrincipal
{
public:
  Principal(
    int i,
    Addr a,
    bool replica,
    const uint8_t* pub_key_sig,
    uint8_t* pub_key_enc);
  // Requires: "pkey" points to a null-terminated ascii encoding of
  // an integer in base-16 or is null (in which case no public-key is
  // associated with the principal.)
  // Effects: Creates a new Principal object.

  virtual ~Principal() = default;
  // Effects: Deallocates all the storage associated with principal.

  int pid() const;
  // Effects: Returns the principal identifier.

  const Addr* address() const;
  // Effects: Returns a pointer to the principal's address.

  bool is_replica() const;
  // Effects: Returns true iff this is a replica

  const std::array<uint8_t, Asym_key_size>& get_pub_key_enc() const;

  int sig_size() const;
  // Effects: Returns the size of signatures generated by this principal.

  bool verify_signature(
    const char* src,
    unsigned src_len,
    const char* sig,
    bool allow_self = false);
  // Requires: "sig" is at least sig_size() bytes.
  // Effects: Checks a signature "sig" (from this principal) for
  // "src_len" bytes starting at "src". If "allow_self" is false, it
  // always returns false if "this->id == node->id()"; otherwise,
  // returns true if signature is valid.

  unsigned encrypt(
    const char* src,
    unsigned src_len,
    char* dst,
    unsigned dst_len,
    KeyPair* sender_kp);
  // Effects: Encrypts "src_len" bytes starting at "src" using this
  // principal's public-key and places up to "dst_len" of the result in "dst".
  // Returns the number of bytes placed in "dst".

  Request_id last_fetch_rid() const;
  void set_last_fetch_rid(Request_id r);
  // Effects: Gets and sets the last request identifier in a fetch
  // message from this principal.

private:
  int id;
  Addr addr;
  bool replica;
  std::unique_ptr<PublicKey> public_key_sig;
  std::array<uint8_t, Asym_key_size> raw_pub_key_enc;
  int ssize; // signature size
  unsigned
    kin[Key_size_u]; // session key for incoming messages from this principal
  unsigned
    kout[Key_size_u]; // session key for outgoing messages to this principal
  ULong tstamp; // last timestamp in a new-key message from this principal
  Time my_tstamp; // my time when message was accepted

  Request_id
    last_fetch; // Last request_id in a fetch message from this principal
};

inline const Addr* Principal::address() const
{
  return &addr;
}

inline int Principal::pid() const
{
  return id;
}

inline bool Principal::is_replica() const
{
  return replica;
}

inline int Principal::sig_size() const
{
  return ssize;
}

inline const std::array<uint8_t, Asym_key_size>& Principal::get_pub_key_enc()
  const
{
  return raw_pub_key_enc;
}

inline Request_id Principal::last_fetch_rid() const
{
  return last_fetch;
}

inline void Principal::set_last_fetch_rid(Request_id r)
{
  last_fetch = r;
}

void random_nonce(unsigned* n);
// Requires: k is an array of at least Nonce_size bytes.
// Effects: Places a new random nonce with size Nonce_size bytes in n.
